<html>
<head>
	<title>Catacomb 3-D Test</title>
	<link rel="icon" type="image/png" href="favicon.png"/>
	<style>
		body { margin: 0; }
		#cat3d { width: 100%; height: 100%; overflow: hidden; }
	</style>
</head>
<body>
	<div id="cat3d"></div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js" crossorigin="anonymous"></script>
<script id="vertex" type="text/plain">
varying vec3 vNormal;
varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>

void main() {
	#include <begin_vertex>
	#include <project_vertex>

	#include <beginnormal_vertex>
	#include <defaultnormal_vertex>

	vNormal = normalize(transformedNormal);
	vViewPosition = -mvPosition.xyz;

	#include <uv_vertex>
}
</script>
<script id="fragment" type="text/plain">
uniform vec3 diffuse;
uniform float opacity;

varying vec3 vNormal;
varying vec3 vViewPosition;

#include <common>
#include <bsdfs>
#include <fog_pars_fragment>
#include <lights_pars>
#include <map_pars_fragment>
#include <uv_pars_fragment>

void RE_Direct_Pixelated(const in IncidentLight directLight, const in GeometricContext geometry, const in vec3 material, inout ReflectedLight reflectedLight) {

	float dotNL = saturate(dot(geometry.normal, directLight.direction));
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI; // punctual light
	#endif

	reflectedLight.directDiffuse += irradiance * material;
}

void RE_IndirectDiffuse_Pixelated(const in vec3 irradiance, const in GeometricContext geometry, const in vec3 material, inout ReflectedLight reflectedLight) {
	reflectedLight.indirectDiffuse += irradiance * material;  // FIXME: this is a color right now
}

#define RE_Direct          RE_Direct_Pixelated
#define RE_IndirectDiffuse RE_IndirectDiffuse_Pixelated

void main() {

	vec4 diffuseColor = vec4(diffuse, opacity);

	#include <map_fragment>

	#include <normal_flip>
	#include <normal_fragment>

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	vec3 material = diffuseColor.rgb;

	#include <lights_template>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	gl_FragColor = vec4(outgoingLight, diffuseColor.a);

	#include <fog_fragment>
}
</script>
<script>
"use strict";

const gameContainer = document.getElementById("cat3d")

const renderer = new THREE.WebGLRenderer({antialias: true})
renderer.physicallyCorrectLights = true
gameContainer.appendChild(renderer.domElement)

const camera = new THREE.PerspectiveCamera(45, 0, 0.01, 256)
const clock = new THREE.Clock()
const scene = new THREE.Scene()

function resizeView(width, height) {
	renderer.setSize(width, height)
	camera.aspect = width / height
	camera.updateProjectionMatrix()
}

resizeView(gameContainer.clientWidth, gameContainer.clientHeight)

let resizeNextFrame = false
window.addEventListener("resize", () => {
	if (!resizeNextFrame) {
		window.requestAnimationFrame(() => {
			resizeView(gameContainer.clientWidth, gameContainer.clientHeight)
			resizeNextFrame = false
		})
		resizeNextFrame = true
	}
})

function render() {
	const time = clock.getElapsedTime()
	const objectsToRemove = []
	scene.traverse(obj => {
		obj.update && obj.update(time)
		if (obj.shouldRemove) {
			objectsToRemove.push(obj)
		}
	})
	objectsToRemove.forEach(obj => obj.parent.remove(obj))
	renderer.render(scene, camera)
	requestAnimationFrame(render)
}

class CustomMaterial extends THREE.ShaderMaterial {
	constructor(params) {
		const uniforms = THREE.UniformsUtils.merge([
			THREE.UniformsLib.common,
			THREE.UniformsLib.fog,
			THREE.UniformsLib.lights
		])
		super({
			vertexShader: document.getElementById("vertex").textContent,
			fragmentShader: document.getElementById("fragment").textContent,
			uniforms: uniforms,
			fog: true,
			lights: true
		})
		this.setValues(params)
	}

	get color() { return this.uniforms.diffuse.value }

	set color(value) {
		if (value.isColor) {
			this.uniforms.color.diffuse = value
		} else {
			this.uniforms.color.diffuse = new THREE.Color(value)
		}
	}

	get map() { return this.uniforms.map.value }

	set map(value) { this.uniforms.map.value = value }
}
const material = new CustomMaterial({map: new THREE.TextureLoader().load("walls/slime_light.png")})
const box = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), material)
box.position.z = -3
scene.add(box)
const ambient = new THREE.AmbientLight()
const point = new THREE.PointLight(0xFF0000)
point.position.set(1, 1, 1)
scene.add(ambient, point)
render()
</script>
</html>
