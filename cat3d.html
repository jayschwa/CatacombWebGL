<html>
<head>
	<title>Catacomb 3-D Test</title>
	<link rel="icon" type="image/png" href="favicon.png"/>
	<style>
		body { margin: 0; }
		#cat3d { width: 100%; height: 100%; overflow: hidden; }
	</style>
</head>
<body>
	<div id="cat3d"></div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js" crossorigin="anonymous"></script>
<script src="https://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
<script id="vertex" type="text/plain">
varying vec3 vNormal;
varying vec3 vModelPosition;

#include <common>
#include <uv_pars_vertex>

void main() {
	#include <begin_vertex>
	#include <project_vertex>

	#include <beginnormal_vertex>
	#include <defaultnormal_vertex>

	vNormal = normalize(transformedNormal);
	vModelPosition = transformed;

	#include <uv_vertex>
}
</script>
<script id="fragment" type="text/plain">
uniform bool clampColor;
uniform vec3 diffuse;
uniform float interweaveMin;
uniform float interweaveSteps;
uniform float opacity;
uniform int pixelate;

uniform mat4 modelViewMatrix;

varying vec3 vNormal;
varying vec3 vModelPosition;

vec3 colorPalette[16];

void initColorPalette() {
	colorPalette[0] = vec3(0, 0, 0);
	colorPalette[1] = vec3(0, 0, 2.0/3.0);
	colorPalette[2] = vec3(0, 2.0/3.0, 0);
	colorPalette[3] = vec3(0, 2.0/3.0, 2.0/3.0);
	colorPalette[4] = vec3(2.0/3.0, 0, 0);
	colorPalette[5] = vec3(2.0/3.0, 0, 2.0/3.0);
	colorPalette[6] = vec3(2.0/3.0, 1.0/3.0, 0);
	colorPalette[7] = vec3(2.0/3.0, 2.0/3.0, 2.0/3.0);
	colorPalette[8] = vec3(1.0/3.0, 1.0/3.0, 1.0/3.0);
	colorPalette[9] = vec3(1.0/3.0, 1.0/3.0, 1);
	colorPalette[10] = vec3(1.0/3.0, 1, 1.0/3.0);
	colorPalette[11] = vec3(1.0/3.0, 1, 1);
	colorPalette[12] = vec3(1, 1.0/3.0, 1.0/3.0);
	colorPalette[13] = vec3(1, 1.0/3.0, 1);
	colorPalette[14] = vec3(1, 1, 1.0/3.0);
	colorPalette[15] = vec3(1, 1, 1);
}

vec3 clampToPalette(const in vec3 color) {
	float smallestDistance = 100000.0;
	vec3 closestColor = color;
	for (int i = 0; i < 16; i++) {
		float distance = distance(color, colorPalette[i]);
		if (distance < smallestDistance) {
			smallestDistance = distance;
			closestColor = colorPalette[i];
		}
	}
	return closestColor;
}

#include <common>
#include <bsdfs>
#include <fog_pars_fragment>
#include <lights_pars>
#include <map_pars_fragment>
#include <uv_pars_fragment>

void RE_Direct_Pixelated(const in IncidentLight directLight, const in GeometricContext geometry, const in vec3 material, inout ReflectedLight reflectedLight) {

	float dotNL = saturate(dot(geometry.normal, directLight.direction));
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI; // punctual light
	#endif

	reflectedLight.directDiffuse += mix(irradiance * material, irradiance, 0.5);
}

void RE_IndirectDiffuse_Pixelated(const in vec3 irradiance, const in GeometricContext geometry, const in vec3 material, inout ReflectedLight reflectedLight) {
	reflectedLight.indirectDiffuse += irradiance * material;  // FIXME: this is a color right now
}

#define RE_Direct          RE_Direct_Pixelated
#define RE_IndirectDiffuse RE_IndirectDiffuse_Pixelated

void main() {
	initColorPalette();

	vec4 diffuseColor = vec4(diffuse, opacity);

	#include <map_fragment>

	#include <normal_flip>
	#include <normal_fragment>

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	vec3 material = diffuseColor.rgb;

	vec3 modelPosition = vModelPosition;
	float interweave = 1.0;
	if (pixelate > 0) {
		modelPosition = floor(modelPosition * float(pixelate));
		float interweaveStep = (1.0 - interweaveMin) / interweaveSteps;
		interweave = interweaveMin + interweaveStep * mod(dot(modelPosition, vec3(1)), interweaveSteps);
		modelPosition /= float(pixelate);
	}
	vec3 vViewPosition = -(modelViewMatrix * vec4(modelPosition, 1.0)).xyz;

	#include <lights_template>

	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	outgoingLight += reflectedLight.directDiffuse * interweave;
	gl_FragColor = vec4(outgoingLight, diffuseColor.a);

	if (clampColor) {
		gl_FragColor.rgb = clampToPalette(gl_FragColor.rgb);
	}

	#include <fog_fragment>
}
</script>
<script>
"use strict";

class CustomMaterial extends THREE.ShaderMaterial {
	constructor(params) {
		const uniforms = THREE.UniformsUtils.merge([
			THREE.UniformsLib.common,
			THREE.UniformsLib.fog,
			THREE.UniformsLib.lights,
			{
				clampColor: {value: true},
				interweaveMin: {value: 2/3},
				interweaveSteps: {value: 3},
				pixelate: {value: 64}
			}
		])
		super({
			vertexShader: document.getElementById("vertex").textContent,
			fragmentShader: document.getElementById("fragment").textContent,
			uniforms: uniforms,
			fog: true,
			lights: true
		})
		this.setValues(params)
	}

	get clampColor() { return this.uniforms.clampColor.value }
	set clampColor(bool) { this.uniforms.clampColor.value = bool }

	get color() { return this.uniforms.diffuse.value }
	set color(value) {
		if (value.isColor) {
			this.uniforms.diffuse.value = value
		} else {
			this.uniforms.diffuse.value = new THREE.Color(value)
		}
	}

	get interweaveMin() { return this.uniforms.interweaveMin.value }
	set interweaveMin(value) { this.uniforms.interweaveMin.value = value }

	get interweaveSteps() { return this.uniforms.interweaveSteps.value }
	set interweaveSteps(value) { this.uniforms.interweaveSteps.value = value }

	get map() { return this.uniforms.map.value }
	set map(value) { this.uniforms.map.value = value }

	get pixelate() { return this.uniforms.pixelate.value }
	set pixelate(value) { this.uniforms.pixelate.value = value }
}

function clampColor(bool) {
	scene.traverse(obj => {
		if (obj.material && obj.material.clampColor !== undefined) {
			obj.material.clampColor = bool
		}
	})
}

function interweave(min, steps) {
	scene.traverse(obj => {
		if (obj.material && obj.material.interweaveMin !== undefined) {
			obj.material.interweaveMin = min
			obj.material.interweaveSteps = steps || 2
		}
	})
}

function pixelate(value) {
	scene.traverse(obj => {
		if (obj.material && obj.material.pixelate !== undefined) {
			obj.material.pixelate = value
		}
	})
}

THREE.Vector3.prototype.copy = function(v) {
	this.x = v.x
	this.y = v.y
	if (v.isVector3) {
		this.z = v.z
	}
	return this
}

const wallTypeMap = {
	1: "stone",
	2: "slime",
	3: "white",
	4: "blood",
	5: "tar",
	6: "gold",
	7: "hell"
}

function getWallName(type, direction) {
	const suffix = ["north", "south"].includes(direction) ? "dark" : "light"
	return wallTypeMap[type] + "_" + suffix
}

const gameContainer = document.getElementById("cat3d")

const stats = new Stats()
stats.showPanel(0)
gameContainer.appendChild(stats.dom)

const renderer = new THREE.WebGLRenderer({antialias: true})
renderer.physicallyCorrectLights = true
gameContainer.appendChild(renderer.domElement)

const camera = new THREE.PerspectiveCamera(45, 0, 0.01, 256)
const clock = new THREE.Clock()
const scene = new THREE.Scene()

const ambient = new THREE.AmbientLight()
scene.add(ambient)

class TextureCache extends THREE.TextureLoader {
	constructor() {
		super(...arguments)
		this.cache = new Map()
		this.queued = new Map()
		this.stats = new Map()
	}

	load(path, ...args) {
		if (!this.stats.has(path)) {
			this.stats.set(path, {hits: 0, loaded: 0})
		}
		this.stats.get(path).loaded++
		return super.load(path, ...args)
	}

	get(path, onLoad, onProgress, onError) {
		if (this.cache.has(path)) {
			this.stats.get(path).hits++
			const texture = this.cache.get(path)
			onLoad && onLoad(texture)
			return texture
		} else if (this.queued.has(path)) {
			this.stats.get(path).hits++
			const queued = this.queued.get(path)
			queued.onLoad.push(onLoad)
			queued.onProgress.push(onProgress)
			queued.onError.push(onError)
			return queued.texture
		} else {
			const cachedTextures = this.cache
			const queuedTextures = this.queued
			const queued = {
				onLoad: [onLoad],
				onProgress: [onProgress],
				onError: [onError]
			}
			const texture = this.load(path,
				(...args) => {
					cachedTextures.set(path, queued)
					queuedTextures.delete(path)
					queued.onLoad.forEach(f => f && f(...args))
				},
				(...args) => {
					queued.onProgress.forEach(f => f && f(...args))
				},
				(...args) => {
					queuedTextures.delete(path)
					queued.onError.forEach(f => f && f(...args))
				})
			queued.texture = texture
			queuedTextures.set(path, queued)
			texture.magFilter = THREE.NearestFilter
			return texture
		}
	}
}

const textureCache = new TextureCache()

function resizeView(width, height) {
	renderer.setSize(width, height)
	camera.aspect = width / height
	camera.updateProjectionMatrix()
}

resizeView(gameContainer.clientWidth, gameContainer.clientHeight)

let resizeNextFrame = false
window.addEventListener("resize", () => {
	if (!resizeNextFrame) {
		window.requestAnimationFrame(() => {
			resizeView(gameContainer.clientWidth, gameContainer.clientHeight)
			resizeNextFrame = false
		})
		resizeNextFrame = true
	}
})

renderer.domElement.addEventListener("click", event => {
	renderer.domElement.requestPointerLock()
})

class Entity extends THREE.Object3D {
	constructor(size, speed) {
		super()
		this.name = "Entity"
		this.up.set(0, 0, 1)

		this.size = size
		this.speed = speed || 0

		this.moveDirection = new THREE.Vector3()
		this.velocity = new THREE.Vector3()
		this.turnDirection = 0

		this.raycaster = new THREE.Raycaster()
	}

	update(time) {
		const timeDelta = time - this.lastTime
		this.lastTime = time
		if (!timeDelta) { return }

		if (this.turnDirection) {
			this.rotateY(this.turnDirection * timeDelta)
			this.updateVelocity()
		}

		if (this.velocity.lengthSq()) {
			const positionDelta = this.velocity.clone().multiplyScalar(timeDelta)
			for (let i of [0, 1]) {
				const component = positionDelta.getComponent(i)
				const magnitude = Math.abs(component)
				const direction = new THREE.Vector3()
				direction.setComponent(i, Math.sign(component))
				this.raycaster.set(this.position, direction)
				this.raycaster.far = this.size + magnitude
				const collisions = this.raycaster.intersectObject(maze, true)
				if (collisions.length) {
					this.onCollisions(collisions, time)
				}
				for (let collision of collisions) {
					const overlap = this.raycaster.far - collision.distance
					const offset = Math.min(overlap, magnitude)
					positionDelta.addScaledVector(collision.face.normal, offset)
				}
			}
			this.position.add(positionDelta)
		}
	}

	onCollisions() {  /* not implemented */ }

	updateVelocity() {
		this.velocity.copy(this.moveDirection).normalize().multiplyScalar(this.speed)  // velocity in object space
		this.localToWorld(this.velocity).sub(this.position)                            // velocity in world space
		return this.velocity.multiplyScalar(100).roundToZero().divideScalar(100)       // round tiny values to zero
	}
}

class Enemy extends Entity {
	constructor(sprite, size, speed, frames) {
		super(size, speed)
		textureCache.get(sprite, texture => {
			this.texture = new SpriteSheetProxy(texture, frames)
			this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({fog: true, map: this.texture}))
			this.add(this.sprite)
		})
	}

	update(time) {
		if (this.texture) {
			const frame = Math.floor(this.speed * time) % 4
			this.texture.setFrame(frame)
		}
	}
}

class Orc extends Enemy {
	constructor(position) {
		super("sprites/orc.png", 0.5, 5, 10)
		this.position.copy(position)
	}
}

const fireballTexture = textureCache.get("sprites/fireball.png")

class Fireball extends Entity {
	constructor(origin, direction, isBig) {
		super(0, 30)
		this.isBig = isBig
		this.name = isBig? "Big Fireball" : "Fireball"
		this.scale.divideScalar(3)
		this.position.copy(origin)
		this.lookAt(origin.clone().add(direction))
		this.position.addScaledVector(direction, 2/3)
		this.updateMatrixWorld()
		this.moveDirection.z = 1
		this.updateVelocity()

		this.light = new THREE.PointLight(0xFF6600, 0.5, 0.5)
		if (isBig) { this.light.distance *= 2 }
		if (isBig) { this.add(this.light) }

		this.spriteSheet = SpriteSheetProxy(fireballTexture)
		this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: this.spriteSheet}))
		if (!isBig) {
			this.sprite.material.rotation = Math.floor(Math.random() * 4) * Math.PI / 2
		}
		this.add(this.sprite)
	}

	onCollisions(collisions, time) {
		if (!this.removeAtTime) {
			collisions.forEach(collision => {
				for (let obj = collision.object; obj; obj = obj.parent) {
					if (obj.onDamage) {
						obj.onDamage(time)
						break
					}
				}
			})
		}
		if (!this.isBig) {
			this.add(this.light)
		}
		this.removeAtTime = time + 0.075
		this.isBig = false
		this.removeAtTime += 0.075
		this.moveDirection.z = 0
		this.updateVelocity()
		this.translateZ(-0.1)
	}

	update(time) {
		super.update(time)
		let frame = Math.floor(time * 10) % 2
		if (this.isBig) { frame += 2 }
		this.spriteSheet.setFrame(frame)
		if (time >= this.removeAtTime) {
			this.shouldRemove = true
		}
	}
}

class Player extends Entity {
	constructor(camera) {
		super(2/3, 5)
		this.name = "Player"
		camera.rotation.set(0, Math.PI, 0)
		this.add(camera)
		this.camera = camera

		this.light = new THREE.PointLight(0xE55B00, 0, 0)
		this.add(this.light)

		textureCache.get("sprites/hand.png", texture => {
			texture.repeat.y = 1.5
			const spritesheet = SpriteSheetProxy(texture, 2)
			this.hand = new THREE.Sprite(new THREE.SpriteMaterial({map: spritesheet}))
			this.hand.setFrame = (frame) => {
				spritesheet.setFrame(frame)
				this.light.intensity = frame
			}
			this.hand.scale.divideScalar(18)
			this.hand.outPosition = new THREE.Vector3(-0.00265, -0.01375, 0.1)
			this.hand.inPosition = new THREE.Vector3(-0.00265, -0.03, 0.05)
			this.hand.position.copy(this.hand.inPosition)
			this.add(this.hand)
		})
	}

	update(time) {
		super.update(time)
		if (this.hand) {
			this.updateHand(time)
		}
	}

	updateHand(time) {
		const handProgress = (this.hand.position.clone().sub(this.hand.inPosition).length() /
			this.hand.outPosition.clone().sub(this.hand.inPosition).length())
		if (this.chargeStarted) {
			const chargeTime = time - this.chargeStarted
			this.hand.position.lerpVectors(
				this.hand.inPosition,
				this.hand.outPosition,
				Math.min(1, Math.max(handProgress, chargeTime * 2))
			)
			const frame = Math.ceil(chargeTime * 8) % 2
			this.hand.setFrame(frame)
			this.light.distance = Math.min(1, chargeTime) * 2.5
		} else if (this.lastFire) {
			const timeDelta = time - this.lastFire
			this.hand.position.lerpVectors(
				this.hand.outPosition,
				this.hand.inPosition,
				Math.min(1, Math.max(1 - handProgress, timeDelta - 1))
			)
		}
	}

	moveForward(value) { this.moveDirection.z += value; this.updateVelocity() }
	moveBackward(value) { this.moveDirection.z -= value; this.updateVelocity() }
	moveLeft(value) { this.moveDirection.x += value; this.updateVelocity() }
	moveRight(value) { this.moveDirection.x -= value; this.updateVelocity() }
	sprint(value) { this.speed *= (value > 0) ? 2 : 0.5; this.updateVelocity() }
	turnLeft(value) { this.turnDirection += value }
	turnRight(value) { this.turnDirection -= value }
	shoot(value) {
		if (value > 0) {
			this.chargeStarted = this.lastTime
			this.hand.setFrame(1)
			this.light.distance = 0
		} else {
			const chargeTime = this.lastTime - this.chargeStarted
			const fireball = new Fireball(this.position, this.getWorldDirection(), chargeTime > 1)
			scene.add(fireball)
			this.chargeStarted = 0
			this.lastFire = this.lastTime
			this.hand.setFrame(0)

			const handProgress = (this.hand.position.clone().sub(this.hand.inPosition).length() /
				this.hand.outPosition.clone().sub(this.hand.inPosition).length())
			this.hand.position.lerpVectors(
				this.hand.inPosition,
				this.hand.outPosition,
				Math.min(1, handProgress + 0.25)
			)
		}
	}
}

const player = new Player(camera)
scene.add(player)

const binds = {
	ArrowUp: player.moveForward.bind(player),
	ArrowLeft: player.turnLeft.bind(player),
	ArrowDown: player.moveBackward.bind(player),
	ArrowRight: player.turnRight.bind(player),

	KeyW: player.moveForward.bind(player),
	KeyA: player.moveLeft.bind(player),
	KeyS: player.moveBackward.bind(player),
	KeyD: player.moveRight.bind(player),

	ShiftLeft: player.sprint.bind(player)
}

function onKey(value) {
	return (event) => {
		const command = binds[event.code]
		if (command && !event.repeat) {
			command(value)
		}
	}
}

function onMouseButton(value) {
	return (event) => {
		player.shoot(value)
	}
}

function onMouseMove(event) {
	player.rotateY(-event.movementX / 2000)
	player.updateVelocity()
}

const eventHandlers = [
	["keydown", onKey(1)],
	["keyup", onKey(-1)],
	["mousedown", onMouseButton(1)],
	["mouseup", onMouseButton(-1)],
	["mousemove", onMouseMove]
]

document.addEventListener("pointerlockchange", event => {
	if (document.pointerLockElement === renderer.domElement) {
		eventHandlers.forEach(([e, f]) => document.addEventListener(e, f))
	} else {
		eventHandlers.forEach(([e, f]) => document.removeEventListener(e, f))
	}
})

function render() {
	stats.begin()
	const time = clock.getElapsedTime()
	const objectsToRemove = []
	scene.traverse(obj => {
		obj.update && obj.update(time)
		if (obj.shouldRemove) {
			objectsToRemove.push(obj)
		}
	})
	objectsToRemove.forEach(obj => obj.parent.remove(obj))
	renderer.render(scene, player.camera)
	stats.end()
	requestAnimationFrame(render)
}

const PLAYER_START_NORTH = 0x01
const PLAYER_START_EAST = 0x02
const PLAYER_START_SOUTH = 0x03
const PLAYER_START_WEST = 0x04
const PLAYER_START_SET = new Set([PLAYER_START_NORTH, PLAYER_START_EAST, PLAYER_START_SOUTH, PLAYER_START_WEST])

const TELEPORTER_A = 0x1F
const TELEPORTER_B = 0x20
const TELEPORTER_C = 0x21
const TELEPORTER_SET = new Set([TELEPORTER_A, TELEPORTER_B, TELEPORTER_C])

class ExplodingWall extends THREE.Object3D {
	constructor(tileIndex) {
		super()
		const geometry = new THREE.BoxBufferGeometry(1, 1, 1)
		geometry.rotateX(Math.PI / 2)
		const texture = textureCache.get("walls/exploding.png", texture => {
			this.box.material.map = new SpriteSheetProxy(texture)
			this.box.material.needsUpdate = true
		})
		const material = new THREE.MeshBasicMaterial({map: texture, transparent: true})
		this.box = new THREE.Mesh(geometry, material)
		this.duration = 1/3
		this.adjacentIndices = []
		this.tileIndex = tileIndex
	}

	ignite(time) {
		if (this.isExploding()) {
			return
		}
		this.ignition = time
		this.children.forEach(mesh => mesh.shouldRemove = true)
		this.add(this.box)
	}

	igniteAdjacent(time) {
		// FIXME: determine adjacents at initialization
		const adjacent = this.parent.children.filter(e => this.adjacentIndices.includes(e.tileIndex))
		adjacent.forEach(wall => wall.ignite(time))
		this.adjacentsIgnited = true
	}

	isExploding() {
		return !!this.ignition
	}

	onDamage(time) {
		this.ignite(time)
	}

	update(time) {
		if (this.isExploding()) {
			const timeDelta = time - this.ignition
			if (timeDelta > this.duration) {
				this.shouldRemove = true
			} else {
				const texture = this.box.material.map
				const frame = Math.floor(timeDelta * texture.frames / this.duration)
				this.box.material.map.setFrame(frame)
				if (!this.adjacentsIgnited && timeDelta > this.duration / texture.frames) {
					this.igniteAdjacent(time)
				}
			}
		}
	}
}

class Tile {
	constructor(map, index, position, layout, entity) {
		this.map = map
		this.index = index
		this.position = position
		this.layout = layout
		this.entity = entity
	}

	adjacentTiles() {
		// TODO: Tile should not be aware of how data is laid out in Map
		return [
			this.index - 1,
			this.index + 1,
			this.index - this.map.width,
			this.index + this.map.width
		]
		.filter(idx => 0 <= idx && idx < this.map.size())
		.map(idx => this.map.tileAt(idx))
	}

	directionTo(other) {
		const tx = this.position.x
		const ty = this.position.y
		const ox = other.position.x
		const oy = other.position.y
		if (tx < ox && ty == oy) {
			return "east"
		} else if (tx > ox && ty == oy) {
			return "west"
		} else if (ty < oy && tx == ox) {
			return "north"
		} else if (ty > oy && tx == ox) {
			return "south"
		}
		return null
	}

	isFloor() {
		return !(this.isWall() || this.isExplodable())
	}

	isWall() {
		return wallTypeMap[this.layout] !== undefined
	}

	isExplodable() {
		return wallTypeMap[this.layout-7] !== undefined
	}
}

function isStartOrTeleport(tile) {
	return PLAYER_START_SET.has(tile.entity) || TELEPORTER_SET.has(tile.entity)
}

class TileMap {
	constructor(bytes) {
		this.width = bytes[0]
		this.height = bytes[1]
		this.layout = bytes.slice(2, this.size() + 2)
		this.entities = bytes.slice(this.size() + 2)
	}

	positionAt(index) {
		let x = index % this.width
		let y = this.height - Math.floor(index / this.width)
		return new THREE.Vector2(x, y)
	}

	size() {
		return this.width * this.height
	}

	tileAt(index) {
		return new Tile(this, index, this.positionAt(index), this.layout[index], this.entities[index])
	}

	tiles() {
		const tiles = []
		for (let i = 0; i < this.size(); i++) {
			tiles.push(this.tileAt(i))
		}
		return tiles
	}
}

function fetchMapAndRender(name) {
	fetch("maps/" + name + ".c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		const map = new TileMap(new Uint8Array(buffer))
		console.log("map dimensions: " + map.width + "x" + map.height)
		const hellish = map.layout.includes(7)
		const fogColor = hellish ? 0x330000 : 0x000000  // hell gets red tint
		scene.fog = new THREE.Fog(fogColor, 1, Math.max(40, 1.25 * Math.max(map.width, map.height)))
		setupMaze(map, scene)
		setupPlayerSpawn(map)
		addPortals(map, scene)
		addEnemies(map, scene)
		render()
	});
}

class FloorGeometry extends THREE.PlaneGeometry {
	constructor(position) {
		super(1, 1)
		this.translate(position.x, position.y, -0.5)
	}
}

class WallGeometry extends THREE.PlaneGeometry {
	constructor(position, direction) {
		super(1, 1)
		this.rotateX(Math.PI / 2)
		this.translate(0, -0.5, 0)
		const coeffs = {
			west: -1,
			south: 0,
			east: 1,
			north: 2
		}
		this.rotateZ(coeffs[direction] * Math.PI / 2)
		this.translate(position.x, position.y, 0)
	}
}

const maze = new THREE.Group()
maze.name = "Maze"

function setupMaze(map, scene) {
	const immutable = new THREE.Group()
	const explodable = new THREE.Group()

	const floorGeometry = new THREE.Geometry()
	const wallGeometry = new Map()

	const visited = Array(map.size()).fill(false)
	const queue = map.tiles().filter(isStartOrTeleport)
	queue.forEach(tile => visited[tile.index] = true)

	while (queue.length) {
		const tile = queue.shift()
		const adjacent = tile.adjacentTiles()
		const walls = adjacent.filter(t => t.isWall())

		floorGeometry.merge(new FloorGeometry(tile.position))

		// add static wall geometry
		walls.forEach(wall => {
			const dir = wall.directionTo(tile)
			const name = getWallName(wall.layout, dir)
			if (!wallGeometry.has(name)) {
				wallGeometry.set(name, new THREE.Geometry())
			}
			wallGeometry.get(name).merge(new WallGeometry(wall.position, dir))
		})

		// add explodeable wall geometry
		if (tile.isExplodable()) {
			const explodingWall = new ExplodingWall(tile.index)
			explodingWall.position.copy(tile.position)
			adjacent.filter(a => a.isFloor()).forEach(floor => {
				const dir = tile.directionTo(floor)
				const name = getWallName(tile.layout-7, dir)
				const geometry = new WallGeometry(new THREE.Vector2(), dir)
				const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry)
				const texture = textureCache.get("walls/" + name + ".png")
				texture.anisotropy = renderer.getMaxAnisotropy()
				const material = new CustomMaterial({map: texture})
				const mesh = new THREE.Mesh(bufferGeometry, material)
				explodingWall.add(mesh)
			})
			explodingWall.adjacentIndices = adjacent.filter(e => e.isExplodable()).map(e => e.index)
			explodable.add(explodingWall)
		}

		// enqueue adjacent floor tiles that haven't been visited yet
		const unvisited_floors = adjacent.filter(t => !t.isWall()).filter(t => !visited[t.index])
		unvisited_floors.forEach(tile => {
			queue.push(tile)
			visited[tile.index] = true
		})
	}

	// add floor geometry to scene
	const material = new CustomMaterial({color: 0x555555, clampColor: false, pixelate: 0})
	immutable.add(new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(floorGeometry), material))

	// add aggregate wall geometries to scene
	wallGeometry.forEach((geometry, name) => {
		const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry)
		const texture = textureCache.get("walls/" + name + ".png")
		texture.anisotropy = renderer.getMaxAnisotropy()
		const material = new CustomMaterial({map: texture})
		const mesh = new THREE.Mesh(bufferGeometry, material)
		mesh.name = name
		immutable.add(mesh)
	})
	scene.add(maze.add(immutable, explodable))
}

function setupPlayerSpawn(map) {
	const spawn = map.tiles().filter(t => PLAYER_START_SET.has(t.entity))[0]
	player.position.copy(spawn.position)
	const target = player.position.clone()
	switch (spawn.entity) {
		case PLAYER_START_NORTH: target.y += 1; break
		case PLAYER_START_EAST: target.x += 1; break
		case PLAYER_START_SOUTH: target.y -= 1; break
		case PLAYER_START_WEST: target.x -= 1; break
	}
	player.lookAt(target)
}

const portals = []

class Portal extends THREE.Sprite {

	constructor(position) {
		super()
		this.name = "Portal"
		this.position.copy(position)
		this.fps = 8
		this.light = new THREE.PointLight(0x0042DD, 1, 1.5)
		this.add(this.light)
	}

	update(time) {
		if (this.material.map && this.material.map.isSpriteSheet) {
			const n = Math.floor(time * this.fps) % this.material.map.frames
			this.material.map.setFrame(n)
		}
		this.light.intensity = 0.5 + 0.2 * Math.abs(Math.sin(0.5 * time)) + 0.02 * Math.abs(Math.sin(this.fps * time))
	}
}

function SpriteSheetProxy(texture, frames) {
	const offset = texture.offset.clone()
	const repeat = texture.repeat.clone()
	const proxy = new Proxy(texture, {
		get: function(obj, prop) {
			switch (prop) {
				case "offset": return offset
				case "repeat": return repeat
				default: return obj[prop]
			}
		}
	})
	proxy.frames = frames || Math.floor(texture.image.width / texture.image.height)
	proxy.isSpriteSheet = true
	proxy.setFrame = function(n) {
		if (n < 0 || n >= this.frames) {
			throw new RangeError("Invalid frame number")
		}
		const width = 1 / this.frames
		this.offset.x = n * width
		this.repeat.x = width
	}
	proxy.setFrame(0)
	return proxy
}

function addPortals(map, scene) {
	const portalTiles = map.tiles().filter(t => [0x18, 0x1F, 0x20, 0x21].includes(t.entity))
	for (let tile of portalTiles) {
		const portal = new Portal(tile.position)
		portals.push(portal)
		scene.add(portal)
	}
	textureCache.get("sprites/portal.png", texture => {
		portals.forEach(portal => {
			const spritesheet = SpriteSheetProxy(texture)
			portal.material.map = spritesheet
			portal.material.needsUpdate = true
		})
	})
}

function addEnemies(map, scene) {
	const orcs = map.tiles().filter(t => [0x17, 0x25, 0x2A].includes(t.entity))
	console.log(orcs)

	orcs.forEach(orcTile => {
		const orc = new Orc(orcTile.position)
		scene.add(orc)
		console.log(orc)
	})
}

fetchMapAndRender("0_Approach")

</script>
</html>
