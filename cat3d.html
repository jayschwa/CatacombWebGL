<html>
<head>
	<title>Catacomb 3-D Test</title>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
<script src="FirstPersonControls.js"></script>
<script>

THREE.Vector3.prototype.copy = function(v) {
	this.x = v.x
	this.y = v.y
	if (v.isVector3) {
		this.z = v.z
	}
	return this
}

const wallTypeMap = {
	1: "stone",
	2: "slime",
	3: "white",
	4: "blood",
	5: "tar",
	6: "gold",
	7: "hell"
}

function getWallName(type, direction) {
	const suffix = ["north", "south"].includes(direction) ? "dark" : "light"
	return wallTypeMap[type] + "_" + suffix
}

var clock = new THREE.Clock();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 256);
camera.up.set(0, 0, 1)

var controls = null

var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

var render = function() {
	requestAnimationFrame(render);
	controls.update(clock.getDelta())
	renderer.render(scene, camera);
};

const PLAYER_START_NORTH = 0x01
const PLAYER_START_EAST = 0x02
const PLAYER_START_SOUTH = 0x03
const PLAYER_START_WEST = 0x04
const PLAYER_START_SET = new Set([PLAYER_START_NORTH, PLAYER_START_EAST, PLAYER_START_SOUTH, PLAYER_START_WEST])

const TELEPORTER_A = 0x1F
const TELEPORTER_B = 0x20
const TELEPORTER_C = 0x21
const TELEPORTER_SET = new Set([TELEPORTER_A, TELEPORTER_B, TELEPORTER_C])

class Tile {
	constructor(map, index, position, layout, entity) {
		this.map = map
		this.index = index
		this.position = position
		this.layout = layout
		this.entity = entity
	}

	adjacentTiles() {
		// TODO: Tile should not be aware of how data is laid out in Map
		return [
			this.index - 1,
			this.index + 1,
			this.index - this.map.width,
			this.index + this.map.width
		]
		.filter(idx => 0 <= idx && idx < this.map.size())
		.map(idx => this.map.tileAt(idx))
	}

	directionTo(other) {
		const tx = this.position.x
		const ty = this.position.y
		const ox = other.position.x
		const oy = other.position.y
		if (tx < ox && ty == oy) {
			return "east"
		} else if (tx > ox && ty == oy) {
			return "west"
		} else if (ty < oy && tx == ox) {
			return "north"
		} else if (ty > oy && tx == ox) {
			return "south"
		}
		return null
	}

	isWall() {
		return wallTypeMap[this.layout] !== undefined
	}
}

function isStartOrTeleport(tile) {
	return PLAYER_START_SET.has(tile.entity) || TELEPORTER_SET.has(tile.entity)
}

class TileMap {
	constructor(bytes) {
		this.width = bytes[0]
		this.height = bytes[1]
		this.layout = bytes.slice(2, this.size() + 2)
		this.entities = bytes.slice(this.size() + 2)
	}

	positionAt(index) {
		let x = index % this.width
		let y = this.height - Math.floor(index / this.width)
		return new THREE.Vector2(x, y)
	}

	size() {
		return this.width * this.height
	}

	tileAt(index) {
		return new Tile(this, index, this.positionAt(index), this.layout[index], this.entities[index])
	}

	tiles() {
		const tiles = []
		for (let i = 0; i < this.size(); i++) {
			tiles.push(this.tileAt(i))
		}
		return tiles
	}
}

function fetchMapAndRender() {
	fetch("maps/18_Halls_of_Blood.c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		const map = new TileMap(new Uint8Array(buffer))
		setupWallGeometry(map, scene)
		setupPlayerSpawn(map)
		controls = new THREE.FirstPersonControls(camera, new THREE.Vector3(0, 0, 0.5))
		controls.lookSpeed = 0.05
		controls.lookVertical = false
		render()
	});
}

class FloorGeometry extends THREE.PlaneGeometry {
	constructor(position) {
		super(1, 1)
		this.translate(position.x, position.y, -0.5)
	}
}

class WallGeometry extends THREE.PlaneGeometry {
	constructor(position, direction) {
		super(1, 1)
		this.rotateX(Math.PI / 2)
		this.translate(0, -0.5, 0)
		const coeffs = {
			west: -1,
			south: 0,
			east: 1,
			north: 2
		}
		this.rotateZ(coeffs[direction] * Math.PI / 2)
		this.translate(position.x, position.y, 0)
	}
}

function setupWallGeometry(map, scene) {
	const floorGeometry = new THREE.Geometry()
	const wallGeometry = new Map()
	const visited = Array(map.size()).fill(false)
	const queue = map.tiles().filter(isStartOrTeleport)
	queue.forEach(tile => visited[tile.index] = true)
	while (queue.length) {
		const tile = queue.shift()
		const adjacent = tile.adjacentTiles()
		const walls = adjacent.filter(t => t.isWall())

		floorGeometry.merge(new FloorGeometry(tile.position))

		// add wall geometry
		walls.forEach(wall => {
			const dir = wall.directionTo(tile)
			const name = getWallName(wall.layout, dir)
			if (!wallGeometry.has(name)) {
				wallGeometry.set(name, new THREE.Geometry())
			}
			wallGeometry.get(name).merge(new WallGeometry(wall.position, dir))
		})

		// enqueue adjacent floor tiles that haven't been visited yet
		const unvisited_floors = adjacent.filter(t => !t.isWall()).filter(t => !visited[t.index])
		unvisited_floors.forEach(tile => {
			queue.push(tile)
			visited[tile.index] = true
		})
	}

	// add floor geometry to scene
	const material = new THREE.MeshBasicMaterial({color: 0x555555})
	scene.add(new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(floorGeometry), material))

	// add aggregate wall geometries to scene
	wallGeometry.forEach((geometry, name) => {
		const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry)
		const texture = new THREE.TextureLoader().load("walls/" + name + ".png")
		texture.magFilter = THREE.NearestFilter
		texture.anisotropy = renderer.getMaxAnisotropy()
		const material = new THREE.MeshBasicMaterial({map: texture})
		scene.add(new THREE.Mesh(bufferGeometry, material))
	})
}

function setupPlayerSpawn(map) {
	for (tile of map.tiles()) {
		let e = tile.entity
		if (PLAYER_START_SET.has(tile.entity)) {
			camera.position.copy(tile.position)
			var target = camera.position.clone()
			switch (tile.entity) {
				case PLAYER_START_NORTH: target.y += 1; break
				case PLAYER_START_EAST: target.x += 1; break
				case PLAYER_START_SOUTH: target.y -= 1; break
				case PLAYER_START_WEST: target.x -= 1; break
			}
			camera.lookAt(target)
		}
	}
}
fetchMapAndRender()

</script>
</html>
