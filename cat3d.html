<html>
<head>
	<title>Catacomb 3-D Test</title>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
<script src="FirstPersonControls.js"></script>
<script>

let wallTypes = [
	{id: 1, name: "stone"},
	{id: 2, name: "slime"},
	{id: 3, name: "white"},
	{id: 4, name: "blood"},
	{id: 5, name: "tar"},
	{id: 6, name: "gold"},
	{id: 7, name: "hell"}
]

var clock = new THREE.Clock();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 256);
camera.up.set(0, 0, 1)

var controls = null

var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

var geometry = new THREE.PlaneBufferGeometry(40, 28, 40, 28);
var material = new THREE.MeshBasicMaterial({color: 0x555555});
var plane = new THREE.Mesh(geometry, material);
plane.position.x = 19.5;
plane.position.y = -13.5;
plane.position.z = -0.5;
scene.add(plane);


var geometry = new THREE.BufferGeometry();
// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
var vertices = new Float32Array([
	// East face
	0.5, -0.5, 0.5,
	0.5, -0.5, -0.5,
	0.5, 0.5, -0.5,
	0.5, 0.5, 0.5,

	// North face
	0.5, 0.5, 0.5,
	0.5, 0.5, -0.5,
	-0.5, 0.5, -0.5,
	-0.5, 0.5, 0.5,

	// West face
	-0.5, 0.5, 0.5,
	-0.5, 0.5, -0.5,
	-0.5, -0.5, -0.5,
	-0.5, -0.5, 0.5,

	// South face
	-0.5, -0.5, 0.5,
	-0.5, -0.5, -0.5,
	0.5, -0.5, -0.5,
	0.5, -0.5, 0.5
]);

var indices = new Uint8Array([
	0, 1, 2, 0, 2, 3,
	4, 5, 6, 4, 6, 7,
	8, 9, 10, 8, 10, 11,
	12, 13, 14, 12, 14, 15
])

var uvs = new Float32Array([
	// East face
	0.0, 1,
	0.0, 0,
	0.5, 0,
	0.5, 1,

	// North face
	0.5, 1,
	0.5, 0,
	1.0, 0,
	1.0, 1,

	// West face
	0.0, 1,
	0.0, 0,
	0.5, 0,
	0.5, 1,

	// South face
	0.5, 1,
	0.5, 0,
	1.0, 0,
	1.0, 1
])

// itemSize = 3 because there are 3 values (components) per vertex
geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
geometry.setIndex(new THREE.BufferAttribute(indices, 1))
geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

for (wallType of wallTypes) {
	var texture = new THREE.TextureLoader().load("walls/" + wallType.name + ".png");
	texture.magFilter = THREE.NearestFilter;
	texture.minFilter = THREE.LinearMipMapLinearFilter;
	texture.anisotropy = renderer.getMaxAnisotropy()
	var material = new THREE.MeshBasicMaterial({map: texture});
	wallType.mesh = new THREE.Mesh(geometry, material);
}

var render = function() {
	requestAnimationFrame(render);
	//controls.update(clock.getDelta())
	renderer.render(scene, camera);
};

function fetchMapAndRender() {
	fetch("maps/13_Warrens.c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		let bytes = new Uint8Array(buffer)
		let width = bytes[0]
		let height = bytes[1]
		let size = width * height
		let layout = bytes.slice(2, size+2)
		let entities = bytes.slice(size+2)
		let map = {
			width: width,
			height: height,
			layout: layout,
			entities: entities
		}
		addWallCubes(map, scene)
		render()
	});
}
function addWallCubes(map, scene) {
	for (h = 0; h < map.height; h++) {
		for (w = 0; w < map.width; w++) {
			let idx = h * map.width + w
			let b = map.layout[idx] - 1
			if (0 <= b && b < wallTypes.length) {
				let wall = wallTypes[b].mesh.clone()
				wall.position.set(w, -h, 0)
				scene.add(wall)
			}
			let e = map.entities[idx]
			if (1 <= e && e <= 4) {
				camera.position.set(w, -h, 0)
				var target = camera.position.clone()
				switch (e) {
					case 1: target.y += 1; break
					case 2: target.x += 1; break
					case 3: target.y -= 1; break
					case 4: target.x -= 1; break
				}
				camera.lookAt(target)
			}
		}
	}
	controls = new THREE.FirstPersonControls(camera, target)
	controls.lookSpeed = 0.05
	controls.lookVertical = false
}
fetchMapAndRender()

</script>
</html>
