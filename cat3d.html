<html>
<head>
	<title>Catacomb 3-D Test</title>
	<link rel="icon" type="image/png" href="favicon.png"/>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
<script>

THREE.Vector3.prototype.copy = function(v) {
	this.x = v.x
	this.y = v.y
	if (v.isVector3) {
		this.z = v.z
	}
	return this
}

const wallTypeMap = {
	1: "stone",
	2: "slime",
	3: "white",
	4: "blood",
	5: "tar",
	6: "gold",
	7: "hell"
}

function getWallName(type, direction) {
	const suffix = ["north", "south"].includes(direction) ? "dark" : "light"
	return wallTypeMap[type] + "_" + suffix
}

var clock = new THREE.Clock();
var scene = new THREE.Scene();

var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

renderer.domElement.addEventListener("click", event => {
	renderer.domElement.requestPointerLock()
})

class Player extends THREE.Object3D {
	constructor(camera) {
		super()
		this.up.set(0, 0, 1)

		camera.rotation.set(0, Math.PI, 0)
		this.add(camera)
		this.camera = camera

		this.moveSpeed = 2.5
		this.sprintSpeed = 5

		this.moveDirection = new THREE.Vector2()
		this.moveVelocity = new THREE.Vector2()
		this.turnDirection = 0
	}

	update(time) {
		const delta = time - this.lastTime
		this.lastTime = time
		if (!delta) { return }

		this.translateX(this.moveVelocity.x * delta)
		this.translateZ(this.moveVelocity.y * delta)
		this.rotateY(this.turnDirection * delta)
	}

	updateVelocity() {
		const speed = this.sprinting ? this.sprintSpeed : this.moveSpeed
		return this.moveVelocity.copy(this.moveDirection).normalize().multiplyScalar(speed)
	}

	moveForward(value) { this.moveDirection.y += value; this.updateVelocity() }
	moveBackward(value) { this.moveDirection.y -= value; this.updateVelocity() }
	moveLeft(value) { this.moveDirection.x += value; this.updateVelocity() }
	moveRight(value) { this.moveDirection.x -= value; this.updateVelocity() }
	sprint(value) { this.sprinting = value > 0; this.updateVelocity() }
	turnLeft(value) { this.turnDirection += value }
	turnRight(value) { this.turnDirection -= value }
}

const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 256);
const player = new Player(camera)
scene.add(player)

const binds = {
	ArrowUp: player.moveForward.bind(player),
	ArrowLeft: player.turnLeft.bind(player),
	ArrowDown: player.moveBackward.bind(player),
	ArrowRight: player.turnRight.bind(player),

	KeyW: player.moveForward.bind(player),
	KeyA: player.moveLeft.bind(player),
	KeyS: player.moveBackward.bind(player),
	KeyD: player.moveRight.bind(player),

	ShiftLeft: player.sprint.bind(player)
}

function onKey(value) {
	return (event) => {
		const command = binds[event.code]
		if (command && !event.repeat) {
			command(value)
		}
	}
}

function onMouseMove(event) {
	player.rotateY(-event.movementX / 2000)
}

const eventHandlers = [
	["keydown", onKey(1)],
	["keyup", onKey(-1)],
	["mousemove", onMouseMove]
]

document.addEventListener("pointerlockchange", event => {
	if (document.pointerLockElement === renderer.domElement) {
		eventHandlers.forEach(([e, f]) => document.addEventListener(e, f))
	} else {
		eventHandlers.forEach(([e, f]) => document.removeEventListener(e, f))
	}
})

var render = function() {
	const time = clock.getElapsedTime()
	player.update(time)
	renderer.render(scene, player.camera);
	requestAnimationFrame(render);
};

const PLAYER_START_NORTH = 0x01
const PLAYER_START_EAST = 0x02
const PLAYER_START_SOUTH = 0x03
const PLAYER_START_WEST = 0x04
const PLAYER_START_SET = new Set([PLAYER_START_NORTH, PLAYER_START_EAST, PLAYER_START_SOUTH, PLAYER_START_WEST])

const TELEPORTER_A = 0x1F
const TELEPORTER_B = 0x20
const TELEPORTER_C = 0x21
const TELEPORTER_SET = new Set([TELEPORTER_A, TELEPORTER_B, TELEPORTER_C])

class Tile {
	constructor(map, index, position, layout, entity) {
		this.map = map
		this.index = index
		this.position = position
		this.layout = layout
		this.entity = entity
	}

	adjacentTiles() {
		// TODO: Tile should not be aware of how data is laid out in Map
		return [
			this.index - 1,
			this.index + 1,
			this.index - this.map.width,
			this.index + this.map.width
		]
		.filter(idx => 0 <= idx && idx < this.map.size())
		.map(idx => this.map.tileAt(idx))
	}

	directionTo(other) {
		const tx = this.position.x
		const ty = this.position.y
		const ox = other.position.x
		const oy = other.position.y
		if (tx < ox && ty == oy) {
			return "east"
		} else if (tx > ox && ty == oy) {
			return "west"
		} else if (ty < oy && tx == ox) {
			return "north"
		} else if (ty > oy && tx == ox) {
			return "south"
		}
		return null
	}

	isWall() {
		return wallTypeMap[this.layout] !== undefined
	}
}

function isStartOrTeleport(tile) {
	return PLAYER_START_SET.has(tile.entity) || TELEPORTER_SET.has(tile.entity)
}

class TileMap {
	constructor(bytes) {
		this.width = bytes[0]
		this.height = bytes[1]
		this.layout = bytes.slice(2, this.size() + 2)
		this.entities = bytes.slice(this.size() + 2)
	}

	positionAt(index) {
		let x = index % this.width
		let y = this.height - Math.floor(index / this.width)
		return new THREE.Vector2(x, y)
	}

	size() {
		return this.width * this.height
	}

	tileAt(index) {
		return new Tile(this, index, this.positionAt(index), this.layout[index], this.entities[index])
	}

	tiles() {
		const tiles = []
		for (let i = 0; i < this.size(); i++) {
			tiles.push(this.tileAt(i))
		}
		return tiles
	}
}

function fetchMapAndRender(name) {
	fetch("maps/" + name + ".c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		const map = new TileMap(new Uint8Array(buffer))
		setupWallGeometry(map, scene)
		setupPlayerSpawn(map)
		render()
	});
}

class FloorGeometry extends THREE.PlaneGeometry {
	constructor(position) {
		super(1, 1)
		this.translate(position.x, position.y, -0.5)
	}
}

class WallGeometry extends THREE.PlaneGeometry {
	constructor(position, direction) {
		super(1, 1)
		this.rotateX(Math.PI / 2)
		this.translate(0, -0.5, 0)
		const coeffs = {
			west: -1,
			south: 0,
			east: 1,
			north: 2
		}
		this.rotateZ(coeffs[direction] * Math.PI / 2)
		this.translate(position.x, position.y, 0)
	}
}

function setupWallGeometry(map, scene) {
	const floorGeometry = new THREE.Geometry()
	const wallGeometry = new Map()

	const visited = Array(map.size()).fill(false)
	const queue = map.tiles().filter(isStartOrTeleport)
	queue.forEach(tile => visited[tile.index] = true)

	while (queue.length) {
		const tile = queue.shift()
		const adjacent = tile.adjacentTiles()
		const walls = adjacent.filter(t => t.isWall())

		floorGeometry.merge(new FloorGeometry(tile.position))

		// add wall geometry
		walls.forEach(wall => {
			const dir = wall.directionTo(tile)
			const name = getWallName(wall.layout, dir)
			if (!wallGeometry.has(name)) {
				wallGeometry.set(name, new THREE.Geometry())
			}
			wallGeometry.get(name).merge(new WallGeometry(wall.position, dir))
		})

		// enqueue adjacent floor tiles that haven't been visited yet
		const unvisited_floors = adjacent.filter(t => !t.isWall()).filter(t => !visited[t.index])
		unvisited_floors.forEach(tile => {
			queue.push(tile)
			visited[tile.index] = true
		})
	}

	// add floor geometry to scene
	const material = new THREE.MeshBasicMaterial({color: 0x555555})
	scene.add(new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(floorGeometry), material))

	// add aggregate wall geometries to scene
	wallGeometry.forEach((geometry, name) => {
		const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry)
		const texture = new THREE.TextureLoader().load("walls/" + name + ".png")
		texture.magFilter = THREE.NearestFilter
		texture.anisotropy = renderer.getMaxAnisotropy()
		const material = new THREE.MeshBasicMaterial({map: texture})
		scene.add(new THREE.Mesh(bufferGeometry, material))
	})
}

function setupPlayerSpawn(map) {
	const spawn = map.tiles().filter(t => PLAYER_START_SET.has(t.entity))[0]
	player.position.copy(spawn.position)
	const target = player.position.clone()
	switch (spawn.entity) {
		case PLAYER_START_NORTH: target.y += 1; break
		case PLAYER_START_EAST: target.x += 1; break
		case PLAYER_START_SOUTH: target.y -= 1; break
		case PLAYER_START_WEST: target.x -= 1; break
	}
	player.lookAt(target)
}
fetchMapAndRender("13_Warrens")

</script>
</html>
