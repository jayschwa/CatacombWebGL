<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 256);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.PlaneBufferGeometry(40, 28, 40, 28);
			var material = new THREE.MeshBasicMaterial({color: 0x555555, wireframe: true});
			var plane = new THREE.Mesh(geometry, material);
			plane.position.x = 19.5;
			plane.position.y = -13.5;
			plane.position.z = -0.5;
			scene.add(plane);


			var geometry = new THREE.BufferGeometry();
			// create a simple square shape. We duplicate the top left and bottom right
			// vertices because each vertex needs to appear once per triangle.
			var vertices = new Float32Array([
				// East face
				0.5, -0.5, 0.5,
				0.5, -0.5, -0.5,
				0.5, 0.5, -0.5,
				0.5, -0.5, 0.5,
				0.5, 0.5, -0.5,
				0.5, 0.5, 0.5,

				// North face
				0.5, 0.5, 0.5,
				0.5, 0.5, -0.5,
				-0.5, 0.5, -0.5,
				0.5, 0.5, 0.5,
				-0.5, 0.5, -0.5,
				-0.5, 0.5, 0.5,

				// West face
				-0.5, 0.5, 0.5,
				-0.5, 0.5, -0.5,
				-0.5, -0.5, -0.5,
				-0.5, 0.5, 0.5,
				-0.5, -0.5, -0.5,
				-0.5, -0.5, 0.5,

				// South face
				-0.5, -0.5, 0.5,
				-0.5, -0.5, -0.5,
				0.5, -0.5, -0.5,
				-0.5, -0.5, 0.5,
				0.5, -0.5, -0.5,
				0.5, -0.5, 0.5
			]);

			var uvs = new Float32Array([
				// East face
				0, 1,
				0, 0,
				1, 0,
				0, 1,
				1, 0,
				1, 1,

				// North face
				0, 1,
				0, 0,
				1, 0,
				0, 1,
				1, 0,
				1, 1,

				// West face
				0, 1,
				0, 0,
				1, 0,
				0, 1,
				1, 0,
				1, 1,

				// South face
				0, 1,
				0, 0,
				1, 0,
				0, 1,
				1, 0,
				1, 1
			])

			// itemSize = 3 because there are 3 values (components) per vertex
			geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
			geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));


			var texture = new THREE.TextureLoader().load('pictures/140.png');
			texture.magFilter = THREE.NearestFilter;
			texture.minFilter = THREE.LinearMipMapLinearFilter;

			var material = new THREE.MeshBasicMaterial({map: texture});
			var cube = new THREE.Mesh(geometry, material);
			cube.position.set(1, -1, 0);
			scene.add(cube);

			camera.up.set(0, 0, 1);
			camera.position.x = -1;
			camera.position.y = 1;
			camera.lookAt(cube.position);


			var render = function() {
				requestAnimationFrame(render);
				renderer.render(scene, camera);
			};

			render();
		</script>
	</body>
</html>
<script>
function fetchAndDrawMap() {
	fetch("maps/0_Approach.c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		drawMap(new Uint8Array(buffer))
	});
}
function drawMap(bytes) {
	let container = document.getElementById("map")
	let width = bytes[0]
	let height = bytes[1]
	let size = width * height
	let layout = bytes.slice(2, size+2)
	let entities = bytes.slice(size+2)
	for (h = 0; h < height; h++) {
		for (w = 0; w < width; w++) {
			let idx = h * width + w
			var b = layout[idx]
			if (b > 0x20) {
				b = 0
			}
			if (!b) {
				b = entities[idx]
			}
			if (b) {
				var t = b.toString(16).toUpperCase()
				if (t.length < 2) {
					t = "0" + t
				}
				container.innerText += t
			} else {
				container.innerText += "  "
			}
		}
		container.innerText += "\n"
	}
}
</script>
</html>
