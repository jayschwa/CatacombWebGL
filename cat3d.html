<html>
<head>
	<title>Catacomb 3-D Test</title>
	<link rel="icon" type="image/png" href="favicon.png"/>
	<style>
		body { margin: 0; }
		#cat3d { width: 100%; height: 100%; overflow: hidden; }
	</style>
</head>
<body>
	<div id="cat3d"></div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js" crossorigin="anonymous"></script>
<script src="https://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
<script id="vertex" type="text/plain">
varying vec3 vNormal;
varying vec3 vModelPosition;

#include <common>
#include <uv_pars_vertex>

void main() {
	#include <begin_vertex>
	#include <project_vertex>

	#include <beginnormal_vertex>
	#include <defaultnormal_vertex>

	vNormal = normalize(transformedNormal);
	vModelPosition = transformed;

	#include <uv_vertex>
}
</script>
<script id="fragment" type="text/plain">
uniform bool clampColor;
uniform vec3 diffuse;
uniform float interweaveMin;
uniform float interweaveSteps;
uniform float opacity;
uniform int pixelate;

uniform mat4 modelViewMatrix;

varying vec3 vNormal;
varying vec3 vModelPosition;

vec3 colorPalette[16];

void initColorPalette() {
	colorPalette[0] = vec3(0, 0, 0);
	colorPalette[1] = vec3(0, 0, 2.0/3.0);
	colorPalette[2] = vec3(0, 2.0/3.0, 0);
	colorPalette[3] = vec3(0, 2.0/3.0, 2.0/3.0);
	colorPalette[4] = vec3(2.0/3.0, 0, 0);
	colorPalette[5] = vec3(2.0/3.0, 0, 2.0/3.0);
	colorPalette[6] = vec3(2.0/3.0, 1.0/3.0, 0);
	colorPalette[7] = vec3(2.0/3.0, 2.0/3.0, 2.0/3.0);
	colorPalette[8] = vec3(1.0/3.0, 1.0/3.0, 1.0/3.0);
	colorPalette[9] = vec3(1.0/3.0, 1.0/3.0, 1);
	colorPalette[10] = vec3(1.0/3.0, 1, 1.0/3.0);
	colorPalette[11] = vec3(1.0/3.0, 1, 1);
	colorPalette[12] = vec3(1, 1.0/3.0, 1.0/3.0);
	colorPalette[13] = vec3(1, 1.0/3.0, 1);
	colorPalette[14] = vec3(1, 1, 1.0/3.0);
	colorPalette[15] = vec3(1, 1, 1);
}

vec3 clampToPalette(const in vec3 color) {
	float smallestDistance = 100000.0;
	vec3 closestColor = color;
	for (int i = 0; i < 16; i++) {
		float distance = distance(color, colorPalette[i]);
		if (distance < smallestDistance) {
			smallestDistance = distance;
			closestColor = colorPalette[i];
		}
	}
	return closestColor;
}

#include <common>
#include <bsdfs>
#include <fog_pars_fragment>
#include <lights_pars>
#include <map_pars_fragment>
#include <uv_pars_fragment>

void RE_Direct_Pixelated(const in IncidentLight directLight, const in GeometricContext geometry, const in vec3 material, inout ReflectedLight reflectedLight) {

	float dotNL = saturate(dot(geometry.normal, directLight.direction));
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI; // punctual light
	#endif

	reflectedLight.directDiffuse += mix(irradiance * material, irradiance, 0.5);
}

void RE_IndirectDiffuse_Pixelated(const in vec3 irradiance, const in GeometricContext geometry, const in vec3 material, inout ReflectedLight reflectedLight) {
	reflectedLight.indirectDiffuse += irradiance * material;  // FIXME: this is a color right now
}

#define RE_Direct          RE_Direct_Pixelated
#define RE_IndirectDiffuse RE_IndirectDiffuse_Pixelated

void main() {
	initColorPalette();

	vec4 diffuseColor = vec4(diffuse, opacity);

	#include <map_fragment>

	#include <normal_flip>
	#include <normal_fragment>

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	vec3 material = diffuseColor.rgb;

	vec3 modelPosition = vModelPosition;
	float interweave = 1.0;
	if (pixelate > 0) {
		modelPosition = floor(modelPosition * float(pixelate));
		float interweaveStep = (1.0 - interweaveMin) / interweaveSteps;
		interweave = interweaveMin + interweaveStep * mod(dot(modelPosition, vec3(1)), interweaveSteps);
		modelPosition /= float(pixelate);
	}
	vec3 vViewPosition = -(modelViewMatrix * vec4(modelPosition, 1.0)).xyz;

	#include <lights_template>

	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	outgoingLight += reflectedLight.directDiffuse * interweave;
	gl_FragColor = vec4(outgoingLight, diffuseColor.a);

	if (clampColor) {
		gl_FragColor.rgb = clampToPalette(gl_FragColor.rgb);
	}

	#include <fog_fragment>
}
</script>
<script>
"use strict";

class CustomMaterial extends THREE.ShaderMaterial {
	constructor(params) {
		const uniforms = THREE.UniformsUtils.merge([
			THREE.UniformsLib.common,
			THREE.UniformsLib.fog,
			THREE.UniformsLib.lights,
			{
				clampColor: {value: true},
				interweaveMin: {value: 2/3},
				interweaveSteps: {value: 3},
				pixelate: {value: 64}
			}
		])
		super({
			vertexShader: document.getElementById("vertex").textContent,
			fragmentShader: document.getElementById("fragment").textContent,
			uniforms: uniforms,
			fog: true,
			lights: true
		})
		this.setValues(params)
	}

	get clampColor() { return this.uniforms.clampColor.value }
	set clampColor(bool) { this.uniforms.clampColor.value = bool }

	get color() { return this.uniforms.diffuse.value }
	set color(value) {
		if (value.isColor) {
			this.uniforms.diffuse.value = value
		} else {
			this.uniforms.diffuse.value = new THREE.Color(value)
		}
	}

	get interweaveMin() { return this.uniforms.interweaveMin.value }
	set interweaveMin(value) { this.uniforms.interweaveMin.value = value }

	get interweaveSteps() { return this.uniforms.interweaveSteps.value }
	set interweaveSteps(value) { this.uniforms.interweaveSteps.value = value }

	get map() { return this.uniforms.map.value }
	set map(value) { this.uniforms.map.value = value }

	get pixelate() { return this.uniforms.pixelate.value }
	set pixelate(value) { this.uniforms.pixelate.value = value }
}

function clampColor(bool) {
	scene.traverse(obj => {
		if (obj.material && obj.material.clampColor !== undefined) {
			obj.material.clampColor = bool
		}
	})
}

function interweave(min, steps) {
	scene.traverse(obj => {
		if (obj.material && obj.material.interweaveMin !== undefined) {
			obj.material.interweaveMin = min
			obj.material.interweaveSteps = steps || 2
		}
	})
}

function pixelate(value) {
	scene.traverse(obj => {
		if (obj.material && obj.material.pixelate !== undefined) {
			obj.material.pixelate = value
		}
	})
}

THREE.Vector3.prototype.copy = function(v) {
	this.x = v.x
	this.y = v.y
	if (v.isVector3) {
		this.z = v.z
	}
	return this
}

const wallTypeMap = {
	1: "stone",
	2: "slime",
	3: "white",
	4: "blood",
	5: "tar",
	6: "gold",
	7: "hell"
}

function getWallName(type, direction) {
	const suffix = ["north", "south"].includes(direction) ? "dark" : "light"
	return wallTypeMap[type] + "_" + suffix
}

const gameContainer = document.getElementById("cat3d")

class TextureCache extends THREE.TextureLoader {
	constructor() {
		super(...arguments)
		this.cache = new Map()
		this.queued = new Map()
		this.stats = new Map()
	}

	load(path, ...args) {
		if (!this.stats.has(path)) {
			this.stats.set(path, {hits: 0, loaded: 0})
		}
		this.stats.get(path).loaded++
		return super.load(path, ...args)
	}

	get(path, onLoad, onProgress, onError) {
		if (this.cache.has(path)) {
			this.stats.get(path).hits++
			const texture = this.cache.get(path)
			onLoad && onLoad(texture)
			return texture
		} else if (this.queued.has(path)) {
			this.stats.get(path).hits++
			const queued = this.queued.get(path)
			queued.onLoad.push(onLoad)
			queued.onProgress.push(onProgress)
			queued.onError.push(onError)
			return queued.texture
		} else {
			const cachedTextures = this.cache
			const queuedTextures = this.queued
			const queued = {
				onLoad: [onLoad],
				onProgress: [onProgress],
				onError: [onError]
			}
			const texture = this.load(path,
				(...args) => {
					cachedTextures.set(path, queued)
					queuedTextures.delete(path)
					queued.onLoad.forEach(f => f && f(...args))
				},
				(...args) => {
					queued.onProgress.forEach(f => f && f(...args))
				},
				(...args) => {
					queuedTextures.delete(path)
					queued.onError.forEach(f => f && f(...args))
				})
			queued.texture = texture
			queuedTextures.set(path, queued)
			texture.magFilter = THREE.NearestFilter
			return texture
		}
	}
}

const textureCache = new TextureCache()

class Entity extends THREE.Object3D {
	constructor(size, speed) {
		super()
		this.name = "Entity"
		this.up.set(0, 0, 1)

		this.size = size
		this.speed = speed || 0

		this.moveDirection = new THREE.Vector3()
		this.velocity = new THREE.Vector3()
		this.turnDirection = 0

		this.raycaster = new THREE.Raycaster()
	}

	update(time, maze) {
		const timeDelta = time - this.lastTime
		this.lastTime = time
		if (!timeDelta) { return }

		if (this.turnDirection) {
			this.rotateY(this.turnDirection * timeDelta)
			this.updateVelocity()
		}

		if (this.velocity.lengthSq()) {
			let collided = false
			const positionDelta = this.velocity.clone().multiplyScalar(timeDelta)
			do {
				collided = false
				const magnitude = positionDelta.length()
				const direction = positionDelta.clone().normalize()
				const far = this.size + magnitude
				this.raycaster.set(this.position, direction)
				this.raycaster.far = far
				
				let collisions = this.raycaster.intersectObject(maze, true)

				// FIXME: Three seems to have a terrible bug with sprite raytracing
				collisions = collisions.filter(c => c.face || c.object.getWorldPosition().distanceTo(this.raycaster.ray.origin) <= far)

				for (let collision of collisions) {
					if (ancestorsAreEthereal(collision.object)) {
						continue
					}
					let pushBack = true
					if (this.onCollision) {
						pushBack = this.onCollision(collision, time)
					}
					if (pushBack) {
						const normal = collision.face ? collision.face.normal : direction.clone().negate()
						const overlap = far - collision.distance
						positionDelta.addScaledVector(normal, Math.min(overlap, magnitude))
						collided = true
					}
				}
			} while(collided)

			this.position.add(positionDelta)
		}
	}

	updateVelocity() {
		this.velocity.copy(this.moveDirection).normalize().multiplyScalar(this.speed)  // velocity in object space
		this.localToWorld(this.velocity).sub(this.position)                            // velocity in world space
		return this.velocity.multiplyScalar(100).roundToZero().divideScalar(100)       // round tiny values to zero
	}
}

function ancestorsAreEthereal(object) {
	for (let obj = object; obj; obj = obj.parent) {
		if (obj.isEthereal) {
			return obj.isEthereal
		}
	}
	return false
}

class Enemy extends Entity {
	constructor(sprite, position, size, speed, spriteInfo) {
		super(size, speed)
		this.position.copy(position)
		this.spriteInfo = spriteInfo
		textureCache.get(sprite, texture => {
			const totalFrames = spriteInfo.walkFrames + spriteInfo.attackFrames + spriteInfo.deathFrames
			this.texture = new SpriteSheetProxy(texture, spriteInfo.frameWidth, totalFrames)
			this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({fog: true, map: this.texture}))
			this.add(this.sprite)
		})
	}

	onDamage(time) {
		if (!this.timeOfDeath) {
			this.isEthereal = true
			this.timeOfDeath = time
		}
	}

	update(time) {
		if (this.texture) {
			if (this.timeOfDeath) {
				const timeAfterDeath = time - this.timeOfDeath
				const deathStartFrame = this.texture.frames - this.spriteInfo.deathFrames
				const frame = deathStartFrame + Math.floor(8 * timeAfterDeath)
				if (frame >= this.texture.frames && this.removeDead) {
					this.shouldRemove = true
				} else if (frame < this.texture.frames) {
					this.texture.setFrame(frame)
				}
			} else {
				const frame = Math.floor(this.speed * time) % this.spriteInfo.walkFrames
				this.texture.setFrame(frame)
			}
		}
	}
}

class Orc extends Enemy {
	constructor(position) {
		super("sprites/orc.png", position, 0.5, 5, {
			frameWidth: 51,
			walkFrames: 4,
			attackFrames: 2,
			deathFrames: 4
		})
	}

	static entityIds() {
		return [0x17, 0x25, 0x2A]
	}
}

class Troll extends Enemy {
	constructor(position) {
		super("sprites/troll.png", position, 0.75, 5, {
			frameWidth: 64,
			walkFrames: 4,
			attackFrames: 3,
			deathFrames: 4
		})
	}

	static entityIds() {
		return [0x16, 0x24, 0x29]
	}
}

class Bat extends Enemy {
	constructor(position) {
		super("sprites/bat.png", position, 0.5, 10, {
			frameWidth: 40,
			walkFrames: 4,
			attackFrames: 0,
			deathFrames: 2
		})
		this.scale.x = 40/64
		const scale = 0.8
		this.scale.multiplyScalar(scale)
		this.translateZ(-0.1)
		this.removeDead = true
	}

	static entityIds() {
		return [0x19, 0x26, 0x2B]
	}
}

class Mage extends Enemy {
	constructor(position) {
		super("sprites/mage.png", position, 0.5, 5, {
			frameWidth: 56,
			walkFrames: 2,
			attackFrames: 1,
			deathFrames: 3
		})
		this.scale.x = 56/64
	}

	static entityIds() {
		return [0x1B, 0x28, 0x2D]
	}
}

class Demon extends Enemy {
	constructor(position) {
		super("sprites/demon.png", position, 0.75, 5, {
			frameWidth: 64,
			walkFrames: 4,
			attackFrames: 3,
			deathFrames: 4
		})
	}

	static entityIds() {
		return [0x1A, 0x27, 0x2C]
	}
}

const fireballTexture = textureCache.get("sprites/fireball.png")

class Fireball extends Entity {
	constructor(origin, direction, isBig) {
		super(0, 30)
		this.isBig = isBig
		this.name = isBig? "Big Fireball" : "Fireball"
		this.scale.divideScalar(3)
		this.position.copy(origin)
		this.lookAt(origin.clone().add(direction))
		this.position.addScaledVector(direction, 2/3)
		this.updateMatrixWorld()
		this.moveDirection.z = 1
		this.updateVelocity()

		this.light = new THREE.PointLight(0xFF6600, 0.5, 0.5)
		if (isBig) { this.light.distance *= 2 }
		if (isBig) { this.add(this.light) }

		this.spriteSheet = SpriteSheetProxy(fireballTexture)
		this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: this.spriteSheet}))
		if (!isBig) {
			this.sprite.material.rotation = Math.floor(Math.random() * 4) * Math.PI / 2
		}
		this.add(this.sprite)
	}

	onCollision(collision, time) {
		if (!this.removeAtTime) {
			for (let obj = collision.object; obj; obj = obj.parent) {
				if (obj.onDamage) {
					obj.onDamage(time)
					break
				}
			}
		}
		if (!this.isBig) {
			this.add(this.light)
		}
		this.removeAtTime = time + 0.075
		this.isBig = false
		this.removeAtTime += 0.075
		this.moveDirection.z = 0
		this.updateVelocity()
		this.translateZ(-0.1)
		return true
	}

	update(time, maze) {
		super.update(time, maze)
		let frame = Math.floor(time * 10) % 2
		if (this.isBig) { frame += 2 }
		this.spriteSheet.setFrame(frame)
		if (time >= this.removeAtTime) {
			this.shouldRemove = true
		}
	}
}

class Player extends Entity {
	constructor() {
		super(2/3, 5)
		this.camera = new THREE.PerspectiveCamera(45, 0, 0.01, 256)
		this.name = "Player"
		this.camera.rotation.set(0, Math.PI, 0)
		this.add(this.camera)

		this.light = new THREE.PointLight(0xE55B00, 0, 0)
		this.add(this.light)

		textureCache.get("sprites/hand.png", texture => {
			const spritesheet = SpriteSheetProxy(texture, 88, 2)
			spritesheet.repeat.y = 88/72
			this.hand = new THREE.Sprite(new THREE.SpriteMaterial({map: spritesheet}))
			this.hand.setFrame = (frame) => {
				spritesheet.setFrame(frame)
				this.light.intensity = frame
			}
			this.hand.scale.divideScalar(20)
			this.hand.outPosition = new THREE.Vector3(-0.0032, -0.0165, 0.1)
			this.hand.inPosition = new THREE.Vector3(-0.0032, -0.033, 0.05)
			this.hand.position.copy(this.hand.inPosition)
			this.add(this.hand)
		})
	}

	update(time, maze) {
		super.update(time, maze)
		if (this.hand) {
			this.updateHand(time)
		}
	}

	updateHand(time) {
		const handProgress = (this.hand.position.clone().sub(this.hand.inPosition).length() /
			this.hand.outPosition.clone().sub(this.hand.inPosition).length())
		if (this.chargeStarted) {
			const chargeTime = time - this.chargeStarted
			this.hand.position.lerpVectors(
				this.hand.inPosition,
				this.hand.outPosition,
				Math.min(1, Math.max(handProgress, chargeTime * 2))
			)
			const frame = Math.ceil(chargeTime * 8) % 2
			this.hand.setFrame(frame)
			this.light.distance = Math.min(1, chargeTime) * 2.5
		} else if (this.lastFire) {
			const timeDelta = time - this.lastFire
			this.hand.position.lerpVectors(
				this.hand.outPosition,
				this.hand.inPosition,
				Math.min(1, Math.max(1 - handProgress, timeDelta - 1))
			)
		}
	}

	moveForward(value) { this.moveDirection.z += value; this.updateVelocity() }
	moveBackward(value) { this.moveDirection.z -= value; this.updateVelocity() }
	moveLeft(value) { this.moveDirection.x += value; this.updateVelocity() }
	moveRight(value) { this.moveDirection.x -= value; this.updateVelocity() }
	sprint(value) { this.speed *= (value > 0) ? 2 : 0.5; this.updateVelocity() }
	turnLeft(value) { this.turnDirection += value }
	turnRight(value) { this.turnDirection -= value }
	shoot(value) {
		if (value > 0) {
			this.chargeStarted = this.lastTime
			this.hand.setFrame(1)
			this.light.distance = 0
		} else {
			const chargeTime = this.lastTime - this.chargeStarted
			const fireball = new Fireball(this.position, this.getWorldDirection(), chargeTime > 1)
			this.parent.add(fireball)
			this.chargeStarted = 0
			this.lastFire = this.lastTime
			this.hand.setFrame(0)

			const handProgress = (this.hand.position.clone().sub(this.hand.inPosition).length() /
				this.hand.outPosition.clone().sub(this.hand.inPosition).length())
			this.hand.position.lerpVectors(
				this.hand.inPosition,
				this.hand.outPosition,
				Math.min(1, handProgress + 0.25)
			)
		}
	}
}

function bindsFor(player) {
	return {
		ArrowUp: player.moveForward.bind(player),
		ArrowLeft: player.turnLeft.bind(player),
		ArrowDown: player.moveBackward.bind(player),
		ArrowRight: player.turnRight.bind(player),

		KeyW: player.moveForward.bind(player),
		KeyA: player.moveLeft.bind(player),
		KeyS: player.moveBackward.bind(player),
		KeyD: player.moveRight.bind(player),

		ShiftLeft: player.sprint.bind(player)
	}
}


const PLAYER_START_NORTH = 0x01
const PLAYER_START_EAST = 0x02
const PLAYER_START_SOUTH = 0x03
const PLAYER_START_WEST = 0x04
const PLAYER_START_SET = new Set([PLAYER_START_NORTH, PLAYER_START_EAST, PLAYER_START_SOUTH, PLAYER_START_WEST])

const TELEPORTER_A = 0x1F
const TELEPORTER_B = 0x20
const TELEPORTER_C = 0x21
const TELEPORTER_SET = new Set([TELEPORTER_A, TELEPORTER_B, TELEPORTER_C])

class ExplodingWall extends THREE.Object3D {
	constructor(tileIndex) {
		super()
		const geometry = new THREE.BoxBufferGeometry(1, 1, 1)
		geometry.rotateX(Math.PI / 2)
		const texture = textureCache.get("walls/exploding.png", texture => {
			this.box.material.map = new SpriteSheetProxy(texture, 64, 3)
			this.box.material.needsUpdate = true
		})
		const material = new THREE.MeshBasicMaterial({map: texture, transparent: true})
		this.box = new THREE.Mesh(geometry, material)
		this.duration = 1/3
		this.adjacentIndices = []
		this.tileIndex = tileIndex
	}

	ignite(time) {
		if (this.isExploding()) {
			return
		}
		this.ignition = time
		this.children.forEach(mesh => mesh.shouldRemove = true)
		this.add(this.box)
	}

	igniteAdjacent(time) {
		// FIXME: determine adjacents at initialization
		const adjacent = this.parent.children.filter(e => this.adjacentIndices.includes(e.tileIndex))
		adjacent.forEach(wall => wall.ignite(time))
		this.adjacentsIgnited = true
	}

	isExploding() {
		return !!this.ignition
	}

	onDamage(time) {
		this.ignite(time)
	}

	update(time) {
		if (this.isExploding()) {
			const timeDelta = time - this.ignition
			if (timeDelta > this.duration) {
				this.shouldRemove = true
			} else {
				const texture = this.box.material.map
				const frame = Math.floor(timeDelta * texture.frames / this.duration)
				this.box.material.map.setFrame(frame)
				if (!this.adjacentsIgnited && timeDelta > this.duration / texture.frames) {
					this.igniteAdjacent(time)
				}
			}
		}
	}
}

class Tile {
	constructor(map, index, position, layout, entity) {
		this.map = map
		this.index = index
		this.position = position
		this.layout = layout
		this.entity = entity
	}

	adjacentTiles() {
		// TODO: Tile should not be aware of how data is laid out in Map
		return [
			this.index - 1,
			this.index + 1,
			this.index - this.map.width,
			this.index + this.map.width
		]
		.filter(idx => 0 <= idx && idx < this.map.size())
		.map(idx => this.map.tileAt(idx))
	}

	directionTo(other) {
		const tx = this.position.x
		const ty = this.position.y
		const ox = other.position.x
		const oy = other.position.y
		if (tx < ox && ty == oy) {
			return "east"
		} else if (tx > ox && ty == oy) {
			return "west"
		} else if (ty < oy && tx == ox) {
			return "north"
		} else if (ty > oy && tx == ox) {
			return "south"
		}
		return null
	}

	isFloor() {
		return !(this.isWall() || this.isExplodable())
	}

	isWall() {
		return wallTypeMap[this.layout] !== undefined
	}

	isExplodable() {
		return wallTypeMap[this.layout-7] !== undefined
	}
}

function isStartOrTeleport(tile) {
	return PLAYER_START_SET.has(tile.entity) || TELEPORTER_SET.has(tile.entity)
}

class TileMap {
	constructor(bytes) {
		this.width = bytes[0]
		this.height = bytes[1]
		this.layout = bytes.slice(2, this.size() + 2)
		this.entities = bytes.slice(this.size() + 2)
	}

	positionAt(index) {
		let x = index % this.width
		let y = this.height - Math.floor(index / this.width)
		return new THREE.Vector2(x, y)
	}

	size() {
		return this.width * this.height
	}

	tileAt(index) {
		return new Tile(this, index, this.positionAt(index), this.layout[index], this.entities[index])
	}

	tiles() {
		const tiles = []
		for (let i = 0; i < this.size(); i++) {
			tiles.push(this.tileAt(i))
		}
		return tiles
	}
}

class FloorGeometry extends THREE.PlaneGeometry {
	constructor(position) {
		super(1, 1)
		this.translate(position.x, position.y, -0.5)
	}
}

class WallGeometry extends THREE.PlaneGeometry {
	constructor(position, direction) {
		super(1, 1)
		this.rotateX(Math.PI / 2)
		this.translate(0, -0.5, 0)
		const coeffs = {
			west: -1,
			south: 0,
			east: 1,
			north: 2
		}
		this.rotateZ(coeffs[direction] * Math.PI / 2)
		this.translate(position.x, position.y, 0)
	}
}

function setupMaze(map, scene) {
	const immutable = new THREE.Group()
	const explodable = new THREE.Group()

	const floorGeometry = new THREE.Geometry()
	const wallGeometry = new Map()

	const visited = Array(map.size()).fill(false)
	const queue = map.tiles().filter(isStartOrTeleport)
	queue.forEach(tile => visited[tile.index] = true)

	while (queue.length) {
		const tile = queue.shift()
		const adjacent = tile.adjacentTiles()
		const walls = adjacent.filter(t => t.isWall())

		floorGeometry.merge(new FloorGeometry(tile.position))

		// add static wall geometry
		walls.forEach(wall => {
			const dir = wall.directionTo(tile)
			const name = getWallName(wall.layout, dir)
			if (!wallGeometry.has(name)) {
				wallGeometry.set(name, new THREE.Geometry())
			}
			wallGeometry.get(name).merge(new WallGeometry(wall.position, dir))
		})

		// add explodeable wall geometry
		if (tile.isExplodable()) {
			const explodingWall = new ExplodingWall(tile.index)
			explodingWall.position.copy(tile.position)
			adjacent.filter(a => a.isFloor()).forEach(floor => {
				const dir = tile.directionTo(floor)
				const name = getWallName(tile.layout-7, dir)
				const geometry = new WallGeometry(new THREE.Vector2(), dir)
				const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry)
				const texture = textureCache.get("walls/" + name + ".png")
				texture.anisotropy = 8
				const material = new CustomMaterial({map: texture})
				const mesh = new THREE.Mesh(bufferGeometry, material)
				explodingWall.add(mesh)
			})
			explodingWall.adjacentIndices = adjacent.filter(e => e.isExplodable()).map(e => e.index)
			explodable.add(explodingWall)
		}

		// enqueue adjacent floor tiles that haven't been visited yet
		const unvisited_floors = adjacent.filter(t => !t.isWall()).filter(t => !visited[t.index])
		unvisited_floors.forEach(tile => {
			queue.push(tile)
			visited[tile.index] = true
		})
	}

	// add floor geometry to scene
	const material = new CustomMaterial({color: 0x555555, clampColor: false, pixelate: 0})
	immutable.add(new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(floorGeometry), material))

	// add aggregate wall geometries to scene
	wallGeometry.forEach((geometry, name) => {
		const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry)
		const texture = textureCache.get("walls/" + name + ".png")
		texture.anisotropy = 8
		const material = new CustomMaterial({map: texture})
		const mesh = new THREE.Mesh(bufferGeometry, material)
		mesh.name = name
		immutable.add(mesh)
	})
	scene.add(immutable, explodable)
}

function setupPlayerSpawn(map, player) {
	const spawn = map.tiles().filter(t => PLAYER_START_SET.has(t.entity))[0]
	player.position.copy(spawn.position)
	const target = player.position.clone()
	switch (spawn.entity) {
		case PLAYER_START_NORTH: target.y += 1; break
		case PLAYER_START_EAST: target.x += 1; break
		case PLAYER_START_SOUTH: target.y -= 1; break
		case PLAYER_START_WEST: target.x -= 1; break
	}
	player.lookAt(target)
}

class Portal extends THREE.Sprite {

	constructor(position) {
		super()
		this.name = "Portal"
		this.position.copy(position)
		this.fps = 8
		this.light = new THREE.PointLight(0x0042DD, 1, 1.5)
		this.add(this.light)

		textureCache.get("sprites/portal.png", texture => {
			this.spritesheet = new SpriteSheetProxy(texture)
			this.material.map = this.spritesheet
			this.material.needsUpdate = true
		})
	}

	update(time) {
		if (this.material.map && this.material.map.isSpriteSheet) {
			const n = Math.floor(time * this.fps) % this.material.map.frames
			this.material.map.setFrame(n)
		}
		this.light.intensity = 0.5 + 0.2 * Math.abs(Math.sin(0.5 * time)) + 0.02 * Math.abs(Math.sin(this.fps * time))
	}
}

function SpriteSheetProxy(texture, frameWidth, frames) {
	const offset = texture.offset.clone()
	const repeat = texture.repeat.clone()
	const proxy = new Proxy(texture, {
		get: function(obj, prop) {
			switch (prop) {
				case "offset": return offset
				case "repeat": return repeat
				default: return obj[prop]
			}
		}
	})
	proxy.frameWidth = frameWidth || texture.image.height
	proxy.frames = frames || Math.floor(texture.image.width / proxy.frameWidth)
	proxy.repeat.y = Math.max(1, proxy.frameWidth / texture.image.height)
	proxy.frameUvWidth = proxy.frameWidth / texture.image.width
	proxy.isSpriteSheet = true
	proxy.setFrame = function(n) {
		if (n < 0 || n >= this.frames) {
			throw new RangeError("Invalid frame number")
		}
		this.offset.x = n * this.frameUvWidth
		this.repeat.x = this.frameUvWidth
	}
	proxy.setFrame(0)
	return proxy
}

function addPortals(map, scene) {
	const portalTiles = map.tiles().filter(t => [0x18, 0x1F, 0x20, 0x21].includes(t.entity))
	for (let tile of portalTiles) {
		const portal = new Portal(tile.position)
		scene.add(portal)
	}
}

function addEnemies(map, scene) {
	const enemies = [Orc, Troll, Bat, Mage, Demon]
	const mapTiles = map.tiles()
	enemies.forEach(enemy => {
		const spawnPoints = mapTiles.filter(t => enemy.entityIds().includes(t.entity))
		spawnPoints.forEach(spawn => scene.add(new enemy(spawn.position)))
	})
}

class Game {
	constructor(container, mapName, player) {
		this.container = container
		this.mapName = mapName
		this.player = player || new Player()

		this.clock = new THREE.Clock()

		this.renderer = new THREE.WebGLRenderer({antialias: true})
		this.renderer.physicallyCorrectLights = true
		container.appendChild(this.renderer.domElement)

		this.scene = new THREE.Scene()
		this.ambientLight = new THREE.AmbientLight()
		this.scene.add(this.ambientLight)
		this.scene.add(this.player)

		this.maze = new THREE.Group()
		this.maze.name = "Maze"

		this.stats = new Stats()
		this.stats.showPanel(0)
		container.appendChild(this.stats.dom)
	}

	play() {
		this.isActive = true
		this.render()
	}

	pause() {
		this.isActive = false
	}

	render() {
		this.stats.begin()
		const time = this.clock.getElapsedTime()
		const objectsToRemove = []
		this.scene.traverse(obj => {
			obj.update && obj.update(time, this.maze)
			if (obj.shouldRemove) {
				objectsToRemove.push(obj)
			}
		})
		objectsToRemove.forEach(obj => obj.parent.remove(obj))
		this.renderer.render(this.scene, this.player.camera)
		this.stats.end()
		if (this.isActive) {
			requestAnimationFrame(this.render.bind(this))
		}
	}

	resizeView(width, height) {
		this.renderer.setSize(width, height)
		const cameras = [this.player.camera]
		cameras.forEach(camera => {
			camera.aspect = width / height
			camera.updateProjectionMatrix()
		})
	}


	setup() {
		const that = this
		fetch("maps/" + this.mapName + ".c3dmap")
		.then(function(response) {
			return response.arrayBuffer()
		})
		.then(function(buffer) {
			// TODO: Game should not be aware of map format
			const map = new TileMap(new Uint8Array(buffer))
			console.log("map dimensions: " + map.width + "x" + map.height)
			const hellish = map.layout.includes(7)
			const fogColor = hellish ? 0x330000 : 0x000000  // hell gets red tint
			that.scene.fog = new THREE.Fog(fogColor, 1, Math.max(40, 1.25 * Math.max(map.width, map.height)))
			setupMaze(map, that.maze)
			setupPlayerSpawn(map, that.player)
			addPortals(map, that.maze)
			addEnemies(map, that.maze)
			that.scene.add(that.maze)
			that.play()
		})
	}
}

const game = new Game(gameContainer, "18_Halls_of_Blood")

game.resizeView(gameContainer.clientWidth, gameContainer.clientHeight, [game.player.camera])

let resizeNextFrame = false
window.addEventListener("resize", () => {
	if (!resizeNextFrame) {
		window.requestAnimationFrame(() => {
			game.resizeView(gameContainer.clientWidth, gameContainer.clientHeight)
			resizeNextFrame = false
		})
		resizeNextFrame = true
	}
})

game.renderer.domElement.addEventListener("click", event => {
	game.renderer.domElement.requestPointerLock()
})

function onKey(value) {
	const binds = bindsFor(game.player)
	return (event) => {
		const command = binds[event.code]
		if (command && !event.repeat) {
			command(value)
		}
	}
}

function onMouseButton(value) {
	return (event) => {
		game.player.shoot(value)
	}
}

function onMouseMove(event) {
	game.player.rotateY(-event.movementX / 2000)
	game.player.updateVelocity()
}

const eventHandlers = [
	["keydown", onKey(1)],
	["keyup", onKey(-1)],
	["mousedown", onMouseButton(1)],
	["mouseup", onMouseButton(-1)],
	["mousemove", onMouseMove]
]

document.addEventListener("pointerlockchange", event => {
	if (document.pointerLockElement === game.renderer.domElement) {
		eventHandlers.forEach(([e, f]) => document.addEventListener(e, f))
	} else {
		eventHandlers.forEach(([e, f]) => document.removeEventListener(e, f))
	}
})

game.setup()  // TODO: should be play()

</script>
</html>
