<html>
<head>
	<title>Catacomb 3-D Test</title>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
<script src="FirstPersonControls.js"></script>
<script>

THREE.Vector3.prototype.copy = function(v) {
	this.x = v.x
	this.y = v.y
	if (v.isVector3) {
		this.z = v.z
	}
	return this
}

const wallTypeMap = {
	1: "stone",
	2: "slime",
	3: "white",
	4: "blood",
	5: "tar",
	6: "gold",
	7: "hell"
}

function getWallName(type, direction) {
	const suffix = ["north", "south"].includes(direction) ? "dark" : "light"
	return wallTypeMap[type] + "_" + suffix
}

var clock = new THREE.Clock();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 256);
camera.up.set(0, 0, 1)

var controls = null

var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

function createWallGeometry(position, direction) {
	const verticesByDirection = {
		east: [
			0.5, -0.5, 0.5,
			0.5, -0.5, -0.5,
			0.5, 0.5, -0.5,
			0.5, 0.5, 0.5
		],
		north: [
			0.5, 0.5, 0.5,
			0.5, 0.5, -0.5,
			-0.5, 0.5, -0.5,
			-0.5, 0.5, 0.5
		],
		west: [
			-0.5, 0.5, 0.5,
			-0.5, 0.5, -0.5,
			-0.5, -0.5, -0.5,
			-0.5, -0.5, 0.5
		],
		south: [
			-0.5, -0.5, 0.5,
			-0.5, -0.5, -0.5,
			0.5, -0.5, -0.5,
			0.5, -0.5, 0.5
		]
	}
	vertices = verticesByDirection[direction]
	for (let i = 0; i < vertices.length; i++) {
		if (i % 3 == 0) {
			vertices[i] += position.x
		} else if (i % 3 == 1) {
			vertices[i] += position.y
		}
	}
	return {
		vertices: vertices,
		indices: [0, 1, 2, 0, 2, 3],
		uvs: [0, 1, 0, 0, 1, 0, 1, 1]
	}
}

var render = function() {
	requestAnimationFrame(render);
	controls.update(clock.getDelta())
	renderer.render(scene, camera);
};

const PLAYER_START_NORTH = 0x01
const PLAYER_START_EAST = 0x02
const PLAYER_START_SOUTH = 0x03
const PLAYER_START_WEST = 0x04
const PLAYER_START_SET = new Set([PLAYER_START_NORTH, PLAYER_START_EAST, PLAYER_START_SOUTH, PLAYER_START_WEST])

const TELEPORTER_A = 0x1F
const TELEPORTER_B = 0x20
const TELEPORTER_C = 0x21
const TELEPORTER_SET = new Set([TELEPORTER_A, TELEPORTER_B, TELEPORTER_C])

class Tile {
	constructor(map, index, position, layout, entity) {
		this.map = map
		this.index = index
		this.position = position
		this.layout = layout
		this.entity = entity
	}

	adjacentTiles() {
		// TODO: Tile should not be aware of how data is laid out in Map
		return [
			this.index - 1,
			this.index + 1,
			this.index - this.map.width,
			this.index + this.map.width
		]
		.filter(idx => 0 <= idx && idx < this.map.size())
		.map(idx => this.map.tileAt(idx))
	}

	directionTo(other) {
		const tx = this.position.x
		const ty = this.position.y
		const ox = other.position.x
		const oy = other.position.y
		if (tx < ox && ty == oy) {
			return "east"
		} else if (tx > ox && ty == oy) {
			return "west"
		} else if (ty < oy && tx == ox) {
			return "north"
		} else if (ty > oy && tx == ox) {
			return "south"
		}
		return null
	}

	isWall() {
		return wallTypeMap[this.layout] !== undefined
	}
}

function isStartOrTeleport(tile) {
	return PLAYER_START_SET.has(tile.entity) || TELEPORTER_SET.has(tile.entity)
}

class TileMap {
	constructor(bytes) {
		this.width = bytes[0]
		this.height = bytes[1]
		this.layout = bytes.slice(2, this.size() + 2)
		this.entities = bytes.slice(this.size() + 2)
	}

	positionAt(index) {
		let x = index % this.width
		let y = this.height - Math.floor(index / this.width)
		return new THREE.Vector2(x, y)
	}

	size() {
		return this.width * this.height
	}

	tileAt(index) {
		return new Tile(this, index, this.positionAt(index), this.layout[index], this.entities[index])
	}

	tiles() {
		const tiles = []
		for (let i = 0; i < this.size(); i++) {
			tiles.push(this.tileAt(i))
		}
		return tiles
	}
}

function fetchMapAndRender() {
	fetch("maps/18_Halls_of_Blood.c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		const map = new TileMap(new Uint8Array(buffer))
		setupWallGeometry(map, scene)
		setupPlayerSpawn(map)
		controls = new THREE.FirstPersonControls(camera, new THREE.Vector3(0, 0, 0.5))
		controls.lookSpeed = 0.05
		controls.lookVertical = false
		render()
	});
}

function setupWallGeometry(map, scene) {
	const floorGeometry = {vertices: [], indices: []}
	const wallGeometry = new Map()
	const visited = Array(map.size()).fill(false)
	const queue = map.tiles().filter(isStartOrTeleport)
	queue.forEach(tile => visited[tile.index] = true)
	while (queue.length) {
		const tile = queue.shift()
		const adjacent = tile.adjacentTiles()
		const walls = adjacent.filter(t => t.isWall())

		// add floor geometry
		const fg = function(position) {
			const x = position.x
			const y = position.y
			return {
				vertices: [
					x-0.5, y+0.5, -0.5,
					x-0.5, y-0.5, -0.5,
					x+0.5, y+0.5, -0.5,
					x+0.5, y-0.5, -0.5
				],
				indices: [0, 1, 2, 3, 2, 1	]
			}
		}(tile.position)
		const numFloorVertices = floorGeometry.vertices.length / 3
		floorGeometry.vertices = floorGeometry.vertices.concat(fg.vertices)
		floorGeometry.indices = floorGeometry.indices.concat(fg.indices.map(i => numFloorVertices + i))

		// add wall geometry
		walls.forEach(wall => {
			const dir = wall.directionTo(tile)
			const name = getWallName(wall.layout, dir)
			if (!wallGeometry.has(name)) {
				wallGeometry.set(name, {
					vertices: [],
					indices: [],
					uvs: []
				})
			}
			const wg = wallGeometry.get(name)
			const numVertices = wg.vertices.length / 3
			const newGeometry = createWallGeometry(wall.position, dir)
			wg.vertices = wg.vertices.concat(newGeometry.vertices)
			wg.indices = wg.indices.concat(newGeometry.indices.map(i => numVertices + i))
			wg.uvs = wg.uvs.concat(newGeometry.uvs)
		})

		// enqueue adjacent floor tiles that haven't been visited yet
		const unvisited_floors = adjacent.filter(t => !t.isWall()).filter(t => !visited[t.index])
		unvisited_floors.forEach(tile => {
			queue.push(tile)
			visited[tile.index] = true
		})
	}

	// add floor geometry to scene
	const geometry = new THREE.BufferGeometry()
	geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(floorGeometry.vertices), 3))
	geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(floorGeometry.indices), 1))
	const material = new THREE.MeshBasicMaterial({color: 0x555555})
	scene.add(new THREE.Mesh(geometry, material))

	// add aggregate wall geometries to scene
	wallGeometry.forEach((geometry, name) => {
		const bufferGeometry = new THREE.BufferGeometry()
		bufferGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3))
		bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(geometry.indices), 1))
		bufferGeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2))

		const texture = new THREE.TextureLoader().load("walls/" + name + ".png")
		texture.magFilter = THREE.NearestFilter
		texture.minFilter = THREE.LinearMipMapLinearFilter
		texture.anisotropy = renderer.getMaxAnisotropy()
		const material = new THREE.MeshBasicMaterial({map: texture})
		scene.add(new THREE.Mesh(bufferGeometry, material))
	})
}

function setupPlayerSpawn(map) {
	for (tile of map.tiles()) {
		let e = tile.entity
		if (PLAYER_START_SET.has(tile.entity)) {
			camera.position.copy(tile.position)
			var target = camera.position.clone()
			switch (tile.entity) {
				case PLAYER_START_NORTH: target.y += 1; break
				case PLAYER_START_EAST: target.x += 1; break
				case PLAYER_START_SOUTH: target.y -= 1; break
				case PLAYER_START_WEST: target.x -= 1; break
			}
			camera.lookAt(target)
		}
	}
}
fetchMapAndRender()

</script>
</html>
