<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
		<script src="FirstPersonControls.js"></script>
		<script>
			let wallTypes = [
				{id: 1, name: "stone"},
				{id: 2, name: "slime"},
				{id: 3, name: "white"},
				{id: 4, name: "blood"},
				{id: 5, name: "tar"},
				{id: 6, name: "gold"},
				{id: 7, name: "hell"}
			]

			var clock = new THREE.Clock();
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 256);
			camera.up.set(0, 0, 1)
			camera.position.set(5, -5, 0)
			var controls = new THREE.FirstPersonControls(camera)
			controls.lookSpeed = 0.05
			controls.lookVertical = false

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.PlaneBufferGeometry(40, 28, 40, 28);
			var material = new THREE.MeshBasicMaterial({color: 0x555555});
			var plane = new THREE.Mesh(geometry, material);
			plane.position.x = 19.5;
			plane.position.y = -13.5;
			plane.position.z = -0.5;
			scene.add(plane);


			var geometry = new THREE.BufferGeometry();
			// create a simple square shape. We duplicate the top left and bottom right
			// vertices because each vertex needs to appear once per triangle.
			var vertices = new Float32Array([
				// East face
				0.5, -0.5, 0.5,
				0.5, -0.5, -0.5,
				0.5, 0.5, -0.5,
				0.5, -0.5, 0.5,
				0.5, 0.5, -0.5,
				0.5, 0.5, 0.5,

				// North face
				0.5, 0.5, 0.5,
				0.5, 0.5, -0.5,
				-0.5, 0.5, -0.5,
				0.5, 0.5, 0.5,
				-0.5, 0.5, -0.5,
				-0.5, 0.5, 0.5,

				// West face
				-0.5, 0.5, 0.5,
				-0.5, 0.5, -0.5,
				-0.5, -0.5, -0.5,
				-0.5, 0.5, 0.5,
				-0.5, -0.5, -0.5,
				-0.5, -0.5, 0.5,

				// South face
				-0.5, -0.5, 0.5,
				-0.5, -0.5, -0.5,
				0.5, -0.5, -0.5,
				-0.5, -0.5, 0.5,
				0.5, -0.5, -0.5,
				0.5, -0.5, 0.5
			]);

			var uvs = new Float32Array([
				// East face
				0.0, 1,
				0.0, 0,
				0.5, 0,
				0.0, 1,
				0.5, 0,
				0.5, 1,

				// North face
				0.5, 1,
				0.5, 0,
				1.0, 0,
				0.5, 1,
				1.0, 0,
				1.0, 1,

				// West face
				0.0, 1,
				0.0, 0,
				0.5, 0,
				0.0, 1,
				0.5, 0,
				0.5, 1,

				// South face
				0.5, 1,
				0.5, 0,
				1.0, 0,
				0.5, 1,
				1.0, 0,
				1.0, 1
			])

			// itemSize = 3 because there are 3 values (components) per vertex
			geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
			geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

			for (wallType of wallTypes) {
				var texture = new THREE.TextureLoader().load("walls/" + wallType.name + ".png");
				texture.magFilter = THREE.NearestFilter;
				texture.minFilter = THREE.NearestFilter;
				var material = new THREE.MeshBasicMaterial({map: texture});
				wallType.mesh = new THREE.Mesh(geometry, material);
			}

			var render = function() {
				requestAnimationFrame(render);
				controls.update(clock.getDelta())
				renderer.render(scene, camera);
			};

			function fetchMapAndRender() {
				fetch("maps/0_Approach.c3dmap")
				.then(function(response) {
					return response.arrayBuffer()
				})
				.then(function(buffer) {
					drawMap(new Uint8Array(buffer))
				});
			}
			function drawMap(bytes) {
				let container = document.getElementById("map")
				let width = bytes[0]
				let height = bytes[1]
				let size = width * height
				let layout = bytes.slice(2, size+2)
				let entities = bytes.slice(size+2)
				for (h = 0; h < height; h++) {
					for (w = 0; w < width; w++) {
						let idx = h * width + w
						let b = layout[idx] - 1
						if (0 <= b && b < wallTypes.length) {
							let wall = wallTypes[b].mesh.clone()
							wall.position.set(w, -h, 0)
							scene.add(wall)
						}
						let e = entities[idx]
						if (1 <= e && e <= 4) {
							camera.position.set(w, -h, 0)
						}
					}
				}
				render()
			}
			fetchMapAndRender()
		</script>
	</body>
</html>
<script>

</script>
</html>
