<html>
<head>
	<title>Catacomb 3-D Test</title>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js" integrity="sha256-9ytKBXG7+A+edjlxLzfzHGhMleDxCukt+KYzxDCZ/zI=" crossorigin="anonymous"></script>
<script src="FirstPersonControls.js"></script>
<script>

THREE.Vector3.prototype.copy = function(v) {
	this.x = v.x
	this.y = v.y
	if (v.isVector3) {
		this.z = v.z
	}
	return this
}

let wallTypes = [
	{id: 1, name: "stone"},
	{id: 2, name: "slime"},
	{id: 3, name: "white"},
	{id: 4, name: "blood"},
	{id: 5, name: "tar"},
	{id: 6, name: "gold"},
	{id: 7, name: "hell"}
]

var clock = new THREE.Clock();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 256);
camera.up.set(0, 0, 1)

var controls = null

var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

var geometry = new THREE.PlaneBufferGeometry(40, 28, 40, 28);
var material = new THREE.MeshBasicMaterial({color: 0x555555});
var plane = new THREE.Mesh(geometry, material);
plane.position.x = 19.5;
plane.position.y = 13.5;
plane.position.z = -0.5;
scene.add(plane);


var geometry = new THREE.BufferGeometry();
// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
var vertices = new Float32Array([
	// East face
	0.5, -0.5, 0.5,
	0.5, -0.5, -0.5,
	0.5, 0.5, -0.5,
	0.5, 0.5, 0.5,

	// North face
	0.5, 0.5, 0.5,
	0.5, 0.5, -0.5,
	-0.5, 0.5, -0.5,
	-0.5, 0.5, 0.5,

	// West face
	-0.5, 0.5, 0.5,
	-0.5, 0.5, -0.5,
	-0.5, -0.5, -0.5,
	-0.5, -0.5, 0.5,

	// South face
	-0.5, -0.5, 0.5,
	-0.5, -0.5, -0.5,
	0.5, -0.5, -0.5,
	0.5, -0.5, 0.5
]);

var indices = new Uint8Array([
	0, 1, 2, 0, 2, 3,
	4, 5, 6, 4, 6, 7,
	8, 9, 10, 8, 10, 11,
	12, 13, 14, 12, 14, 15
])

var uvs = new Float32Array([
	// East face
	0.0, 1,
	0.0, 0,
	0.5, 0,
	0.5, 1,

	// North face
	0.5, 1,
	0.5, 0,
	1.0, 0,
	1.0, 1,

	// West face
	0.0, 1,
	0.0, 0,
	0.5, 0,
	0.5, 1,

	// South face
	0.5, 1,
	0.5, 0,
	1.0, 0,
	1.0, 1
])

// itemSize = 3 because there are 3 values (components) per vertex
geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
geometry.setIndex(new THREE.BufferAttribute(indices, 1))
geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

for (wallType of wallTypes) {
	var texture = new THREE.TextureLoader().load("walls/" + wallType.name + ".png");
	texture.magFilter = THREE.NearestFilter;
	texture.minFilter = THREE.LinearMipMapLinearFilter;
	texture.anisotropy = renderer.getMaxAnisotropy()
	var material = new THREE.MeshBasicMaterial({map: texture});
	wallType.mesh = new THREE.Mesh(geometry, material);
}

var render = function() {
	requestAnimationFrame(render);
	//controls.update(clock.getDelta())
	renderer.render(scene, camera);
};

const PLAYER_START_NORTH = 0x01
const PLAYER_START_EAST = 0x02
const PLAYER_START_SOUTH = 0x03
const PLAYER_START_WEST = 0x04
const PLAYER_START_SET = new Set([PLAYER_START_NORTH, PLAYER_START_EAST, PLAYER_START_SOUTH, PLAYER_START_WEST])

const TELEPORTER_A = 0x1F
const TELEPORTER_B = 0x20
const TELEPORTER_C = 0x21
const TELEPORTER_SET = new Set([TELEPORTER_A, TELEPORTER_B, TELEPORTER_C])

class Tile {
	constructor(map, index, position, layout, entity) {
		this.map = map
		this.index = index
		this.position = position
		this.layout = layout
		this.entity = entity
	}

	isWall() {
		let b = this.layout - 1
		return 0 <= b && b < wallTypes.length
	}
}

function isStartOrTeleport(tile) {
	return PLAYER_START_SET.has(tile.entity) || TELEPORTER_SET.has(tile.entity)
}

class Map {
	constructor(bytes) {
		this.width = bytes[0]
		this.height = bytes[1]
		this.layout = bytes.slice(2, this.size() + 2)
		this.entities = bytes.slice(this.size() + 2)
	}

	positionAt(index) {
		let x = index % this.width
		let y = this.height - Math.floor(index / this.width)
		return new THREE.Vector2(x, y)
	}

	size() {
		return this.width * this.height
	}

	tileAt(index) {
		return new Tile(this, index, this.positionAt(index), this.layout[index], this.entities[index])
	}

	tiles() {
		const tiles = []
		for (let i = 0; i < this.size(); i++) {
			tiles.push(this.tileAt(i))
		}
		return tiles
	}
}

function fetchMapAndRender() {
	fetch("maps/13_Warrens.c3dmap")
	.then(function(response) {
		return response.arrayBuffer()
	})
	.then(function(buffer) {
		const map = new Map(new Uint8Array(buffer))
		addWallCubes(map, scene)
		render()
	});
}

function setupWallGeometry(map, scene) {
	const visited = Array(map.size()).fill(false)
	const queue = map.tiles().filter(isStartOrTeleport)
	queue.forEach(tile => visited[tile.index] = true)
	while (queue.length) {
		const tile = queue.shift()
		// add wall geometry
		// for each adjacent, non-wall, and unvisited tile, enqueue
	}
}

function addWallCubes(map, scene) {
	for (tile of map.tiles()) {
		if (tile.isWall()) {
			let b = tile.layout - 1
			let wall = wallTypes[b].mesh.clone()
			wall.position.copy(tile.position)
			scene.add(wall)
		}
		let e = tile.entity
		if (PLAYER_START_SET.has(tile.entity)) {
			camera.position.copy(tile.position)
			var target = camera.position.clone()
			switch (tile.entity) {
				case PLAYER_START_NORTH: target.y += 1; break
				case PLAYER_START_EAST: target.x += 1; break
				case PLAYER_START_SOUTH: target.y -= 1; break
				case PLAYER_START_WEST: target.x -= 1; break
			}
			camera.lookAt(target)
		}
	}
	controls = new THREE.FirstPersonControls(camera, target)
	controls.lookSpeed = 0.05
	controls.lookVertical = false
}
fetchMapAndRender()

</script>
</html>
